diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolAVL.java b/src/main/java/mx/unam/ciencias/edd/ArbolAVL.java
index 305bae2..a2dba95 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolAVL.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolAVL.java
@@ -22,7 +22,7 @@ public class ArbolAVL<T extends Comparable<T>>
          * @param elemento el elemento del vértice.
          */
         public VerticeAVL(T elemento) {
-            // Aquí va su código.
+            super(elemento);
         }
 
         /**
@@ -30,7 +30,7 @@ public class ArbolAVL<T extends Comparable<T>>
          * @return la altura del vértice.
          */
         @Override public int altura() {
-            // Aquí va su código.
+            return altura;
         }
 
         /**
@@ -38,7 +38,7 @@ public class ArbolAVL<T extends Comparable<T>>
          * @return una representación en cadena del vértice AVL.
          */
         @Override public String toString() {
-            // Aquí va su código.
+            return elemento.toString() + " " + altura + "/" + balance(this);
         }
 
         /**
@@ -55,7 +55,7 @@ public class ArbolAVL<T extends Comparable<T>>
             if (objeto == null || getClass() != objeto.getClass())
                 return false;
             @SuppressWarnings("unchecked") VerticeAVL vertice = (VerticeAVL)objeto;
-            // Aquí va su código.
+            return (altura == vertice.altura && super.equals(objeto));   
         }
     }
 
@@ -80,7 +80,12 @@ public class ArbolAVL<T extends Comparable<T>>
      * @return un nuevo vértice con el elemento recibido dentro del mismo.
      */
     @Override protected Vertice nuevoVertice(T elemento) {
-        // Aquí va su código.
+        return new VerticeAVL(elemento);
+    }
+
+    private VerticeAVL verticeAVL(VerticeArbolBinario<T> vertice)
+    {
+        return (VerticeAVL) vertice;
     }
 
     /**
@@ -90,7 +95,8 @@ public class ArbolAVL<T extends Comparable<T>>
      * @param elemento el elemento a agregar.
      */
     @Override public void agrega(T elemento) {
-        // Aquí va su código.
+        super.agrega(elemento);
+        rebalanceo(verticeAVL(ultimoAgregado.padre));
     }
 
     /**
@@ -99,7 +105,60 @@ public class ArbolAVL<T extends Comparable<T>>
      * @param elemento el elemento a eliminar del árbol.
      */
     @Override public void elimina(T elemento) {
-        // Aquí va su código.
+        VerticeAVL vertice = verticeAVL(super.busca(elemento));
+        if (vertice == null)
+           return;
+        elementos--;
+        if (vertice.izquierdo != null && vertice.derecho != null)
+            vertice = verticeAVL(intercambiaEliminable(vertice));
+        eliminaVertice(vertice);
+        rebalanceo(verticeAVL(vertice.padre));
+    }
+
+    private void rebalanceo(VerticeAVL vertice)
+    {
+        if (vertice == null)
+            return;
+        actualiza(vertice);
+        if (balance(vertice) == -2) {
+            VerticeAVL va = verticeAVL(vertice.derecho);
+            if (balance(va) == 1) {
+                super.giraDerecha(va);
+                actualiza(va);
+                va = verticeAVL(vertice.derecho);
+            }
+            super.giraIzquierda(vertice);
+            actualiza(vertice);
+        } else if (balance(vertice) == 2) {
+            VerticeAVL vb = verticeAVL(vertice.izquierdo);
+            if (balance(vertice) == -1) {
+                super.giraIzquierda(vb);
+                actualiza(vb);
+                vb = verticeAVL(vertice.izquierdo);
+            }
+            super.giraDerecha(vertice);
+            actualiza(vertice);
+        }
+        rebalanceo(verticeAVL(vertice.padre));
+    }
+
+    private int balance(VerticeAVL vertice)
+    {
+        if (vertice == null)
+            return 0;
+        return altura(verticeAVL(vertice.izquierdo)) - altura(verticeAVL(vertice.derecho));
+    }
+
+    private int altura(VerticeAVL vertice)
+    {
+        if (vertice == null)
+            return -1;
+        return vertice.altura;
+    }
+
+    private void actualiza(VerticeAVL vertice)
+    {
+        vertice.altura = 1 + Integer.max(altura(verticeAVL(vertice.izquierdo)),altura(verticeAVL(vertice.derecho)));
     }
 
     /**
diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java b/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java
index c3893e9..21d7881 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java
@@ -29,7 +29,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @param elemento el elemento del vértice.
          */
         public Vertice(T elemento) {
-            // Aquí va su código.
+            this.elemento = elemento;
         }
 
         /**
@@ -38,7 +38,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          *         <code>false</code> en otro caso.
          */
         @Override public boolean hayPadre() {
-            // Aquí va su código.
+            return this.padre != null;
         }
 
         /**
@@ -47,7 +47,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          *         <code>false</code> en otro caso.
          */
         @Override public boolean hayIzquierdo() {
-            // Aquí va su código.
+            return this.izquierdo != null;
         }
 
         /**
@@ -56,7 +56,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          *         <code>false</code> en otro caso.
          */
         @Override public boolean hayDerecho() {
-            // Aquí va su código.
+            return this.derecho != null;
         }
 
         /**
@@ -65,16 +65,20 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @throws NoSuchElementException si el vértice no tiene padre.
          */
         @Override public VerticeArbolBinario<T> padre() {
-            // Aquí va su código.
+            if (!this.hayPadre())
+            	throw new NoSuchElementException();
+            return this.padre;
+            
         }
-
         /**
          * Regresa el izquierdo del vértice.
          * @return el izquierdo del vértice.
          * @throws NoSuchElementException si el vértice no tiene izquierdo.
          */
         @Override public VerticeArbolBinario<T> izquierdo() {
-            // Aquí va su código.
+            if (!this.hayIzquierdo())
+            throw new NoSuchElementException();
+            return this.izquierdo;
         }
 
         /**
@@ -83,7 +87,9 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @throws NoSuchElementException si el vértice no tiene derecho.
          */
         @Override public VerticeArbolBinario<T> derecho() {
-            // Aquí va su código.
+            if (!this.hayDerecho())
+            throw new NoSuchElementException();
+            return this.derecho;
         }
 
         /**
@@ -91,7 +97,16 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return la altura del vértice.
          */
         @Override public int altura() {
-            // Aquí va su código.
+            if (this == null)
+                return -1;
+            if (this.izquierdo != null && this.derecho != null)
+                return Integer.max(this.izquierdo.altura(),this.derecho.altura())+1;
+            if (this.izquierdo == null && this.derecho != null)
+                return this.derecho.altura() +1;
+            if (this.izquierdo != null && this.derecho == null)
+                return this.izquierdo.altura() +1;
+
+            return 0;
         }
 
         /**
@@ -99,7 +114,10 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return la profundidad del vértice.
          */
         @Override public int profundidad() {
-            // Aquí va su código.
+        	if (hayPadre())
+        		return (1 + padre.profundidad());
+        	else
+        		return 0;
         }
 
         /**
@@ -107,7 +125,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return el elemento al que apunta el vértice.
          */
         @Override public T get() {
-            // Aquí va su código.
+            return this.elemento;
         }
 
         /**
@@ -124,7 +142,16 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
             if (objeto == null || getClass() != objeto.getClass())
                 return false;
             @SuppressWarnings("unchecked") Vertice vertice = (Vertice)objeto;
-            // Aquí va su código.
+            return equals(this, vertice);
+        }
+
+        private boolean equals(Vertice v1, Vertice v2)
+        {
+            if (v1 == null && v2 == null)
+                return true;
+            if ((v1 == null && v2 != null) || (v1 != null && v2 == null))
+                return false;
+            return equals(v1.izquierdo,v2.izquierdo) && equals(v1.derecho, v2.derecho);
         }
 
         /**
@@ -132,7 +159,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          * @return una representación en cadena del vértice.
          */
         public String toString() {
-            // Aquí va su código.
+            return String.valueOf(this.elemento);
         }
     }
 
@@ -153,7 +180,8 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      *        binario.
      */
     public ArbolBinario(Coleccion<T> coleccion) {
-        // Aquí va su código.
+        for (T t : coleccion)
+        this.agrega(t);
     }
 
     /**
@@ -166,7 +194,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @return un nuevo vértice con el elemento recibido dentro del mismo.
      */
     protected Vertice nuevoVertice(T elemento) {
-        // Aquí va su código.
+        return new Vertice(elemento);
     }
 
     /**
@@ -175,7 +203,10 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @return la altura del árbol.
      */
     public int altura() {
-        // Aquí va su código.
+        if (raiz == null)
+            return -1;
+        else
+            return raiz.altura();
     }
 
     /**
@@ -183,7 +214,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @return el número de elementos en el árbol.
      */
     @Override public int getElementos() {
-        // Aquí va su código.
+        return this.elementos;
     }
 
     /**
@@ -193,7 +224,10 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      *         <code>false</code> en otro caso.
      */
     @Override public boolean contiene(T elemento) {
-        // Aquí va su código.
+        if (busca(elemento) != null)
+        	return true;
+        else
+        	return false;
     }
 
     /**
@@ -204,7 +238,17 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      *         <code>null</code> en otro caso.
      */
     public VerticeArbolBinario<T> busca(T elemento) {
-        // Aquí va su código.
+        return busca(raiz,elemento);
+    }
+
+    private Vertice busca(Vertice vertice,T elemento)
+    {
+        if (vertice == null)
+            return null;    
+        if (vertice.elemento.equals(elemento))
+            return vertice;
+        Vertice v = busca(vertice.izquierdo,elemento);
+        return ((v != null ) ? v : busca(vertice.derecho,elemento));
     }
 
     /**
@@ -213,7 +257,9 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      * @throws NoSuchElementException si el árbol es vacío.
      */
     public VerticeArbolBinario<T> raiz() {
-        // Aquí va su código.
+        if (this.esVacia())
+            throw new NoSuchElementException();
+        return this.raiz;
     }
 
     /**
@@ -222,14 +268,15 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      *         otro caso.
      */
     @Override public boolean esVacia() {
-        // Aquí va su código.
+        return this.raiz == null;
     }
 
     /**
      * Limpia el árbol de elementos, dejándolo vacío.
      */
     @Override public void limpia() {
-        // Aquí va su código.
+    	this.raiz = null;
+    	this.elementos = 0;
     }
 
     /**
@@ -243,15 +290,73 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
             return false;
         @SuppressWarnings("unchecked")
             ArbolBinario<T> arbol = (ArbolBinario<T>)objeto;
-        // Aquí va su código.
+        if (this.esVacia())
+            return arbol.esVacia();
+        return this.raiz.equals(arbol.raiz);
     }
 
     /**
      * Regresa una representación en cadena del árbol.
      * @return una representación en cadena del árbol.
      */
-    @Override public String toString() {
-        // Aquí va su código.
+    @Override public String toString()
+    {
+        if (raiz == null)
+        return "";
+    	int altura = altura() + 1;
+    	int [] arreglo = new int[altura];
+    	for (int i=0; i<altura; i++)
+    		arreglo[i] = 0;
+    	return toString(raiz,0,arreglo);
+    }
+
+    private String toString(Vertice v , int l, int [] arreglo)
+    {
+        String s = v.toString() + "\n";
+        arreglo[l] = 1;
+        if (v.hayIzquierdo() && v.hayDerecho())
+        {
+            s += espacios(l,arreglo);
+            s += "├─›";
+            s += toString(v.izquierdo,l+1,arreglo);
+            s += espacios(l,arreglo);
+            s += "└─»";
+            arreglo[l] = 0;
+            s += toString(v.derecho,l+1,arreglo);
+        }
+		else if (v.hayIzquierdo())
+        {
+                s += espacios(l,arreglo);
+                s += "└─›";
+                arreglo[l] = 0;
+                s += toString(v.izquierdo,l+1,arreglo);
+        }
+            else if (v.hayDerecho())
+            {
+                s += espacios(l,arreglo);
+                s += "└─»";
+                arreglo[l] = 0;
+                s += toString(v.derecho,l+1,arreglo);
+            }
+            return s;
+    } 
+
+    private String espacios(int l,int [] arreglo)
+    {
+        String s = "";
+        for(int i = 0; i < l; i++)
+        {
+        if(arreglo[i] == 1)
+           	s += "│  ";
+        else
+            s += "   ";
+        }
+        return s;
+    }    
+
+    protected boolean esHoja(Vertice vertice)
+    {
+        return !vertice.hayDerecho() && !vertice.hayIzquierdo();
     }
 
     /**
diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java
index 97a2ea0..1d022a6 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java
@@ -18,17 +18,24 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
 
         /* Inicializa al iterador. */
         public Iterador() {
-            // Aquí va su código.
+        cola = new Cola<Vertice>();
+        if (raiz != null)
+        cola.mete(raiz);
         }
 
         /* Nos dice si hay un elemento siguiente. */
         @Override public boolean hasNext() {
-            // Aquí va su código.
+            return !cola.esVacia();
         }
 
         /* Regresa el siguiente elemento en orden BFS. */
         @Override public T next() {
-            // Aquí va su código.
+            Vertice vv = cola.saca();
+            if (vv.izquierdo != null)
+                cola.mete(vv.izquierdo);
+            if (vv.derecho != null)
+                cola.mete(vv.derecho);
+            return vv.get();
         }
     }
 
@@ -55,8 +62,43 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      * @throws IllegalArgumentException si <code>elemento</code> es
      *         <code>null</code>.
      */
-    @Override public void agrega(T elemento) {
-        // Aquí va su código.
+    @Override public void agrega(T elemento)
+    {
+        if (elemento == null)
+            throw new IllegalArgumentException();
+        Vertice v = new Vertice(elemento);
+        if (raiz == null)
+        {
+            raiz = v;
+            elementos++;
+            return;
+        }
+        Vertice vv = raiz;
+        Cola<Vertice> cola = new Cola<Vertice>();
+        cola.mete(vv);
+        while (!cola.esVacia())
+        {
+            vv = cola.saca();
+            if (!vv.hayIzquierdo() || !vv.hayDerecho())
+            {
+                if (!vv.hayIzquierdo())
+                {
+                    vv.izquierdo = v;
+                    v.padre = vv;
+                    elementos++;
+                    return;
+                }
+                if (!vv.hayDerecho())
+                {
+                    vv.derecho = v;
+                    v.padre = vv;
+                    elementos++;
+                    return;
+                }
+            }
+            cola.mete(vv.izquierdo);
+            cola.mete(vv.derecho);
+        }
     }
 
     /**
@@ -65,8 +107,33 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      * eliminado.
      * @param elemento el elemento a eliminar.
      */
-    @Override public void elimina(T elemento) {
-        // Aquí va su código.
+    @Override public void elimina(T elemento)
+    {
+        Vertice vv = (Vertice)busca(elemento);
+        if (vv == null)
+            return;
+        elementos--;
+        if (elementos == 0)
+            raiz = null;
+        Cola<Vertice> vertices = new Cola<Vertice>();
+        if (raiz == null)
+            return;
+        vertices.mete(raiz);
+        Vertice ultimo = null;
+        while (!vertices.esVacia())
+        {
+            ultimo = vertices.saca();
+            if (ultimo.hayIzquierdo())
+                vertices.mete(ultimo.izquierdo);
+            if (ultimo.hayDerecho())
+                vertices.mete(ultimo.derecho);
+        }
+            vv.elemento = ultimo.elemento;
+            Vertice padre = ultimo.padre;
+            if (padre.izquierdo == ultimo)
+                padre.izquierdo = null;
+            else
+                padre.derecho = null;
     }
 
     /**
@@ -75,7 +142,10 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      * @return la altura del árbol.
      */
     @Override public int altura() {
-        // Aquí va su código.
+        if (raiz == null)
+            return -1;
+        else
+            return raiz.altura();
     }
 
     /**
@@ -84,7 +154,17 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void bfs(AccionVerticeArbolBinario<T> accion) {
-        // Aquí va su código.
+        Cola<Vertice> cola = new Cola<Vertice>();
+        cola.mete(raiz);
+        while (!cola.esVacia())
+        {
+            Vertice v = cola.saca();
+            accion.actua(v);
+            if (v.hayIzquierdo())
+                cola.mete(v.izquierdo);
+            if (v.hayDerecho())
+                cola.mete(v.derecho);
+        }
     }
 
     /**
diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java
index ea913b1..d908a12 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java
@@ -24,18 +24,36 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
         private Pila<Vertice> pila;
 
         /* Inicializa al iterador. */
-        public Iterador() {
-            // Aquí va su código.
+        public Iterador()
+        {
+            pila = new Pila<Vertice>();
+            pila = new Pila<Vertice>();
+            Vertice aux = raiz;
+            while(aux != null)
+            {
+              pila.mete(aux);
+              aux = aux.izquierdo;
+            }
         }
 
         /* Nos dice si hay un elemento siguiente. */
         @Override public boolean hasNext() {
-            // Aquí va su código.
+            return !pila.esVacia();
         }
 
         /* Regresa el siguiente elemento en orden DFS in-order. */
         @Override public T next() {
-            // Aquí va su código.
+            Vertice v = pila.saca(), vv;
+            if (v.hayDerecho())
+            {
+                vv = v.derecho;
+                while (vv != null)
+                {
+                    pila.mete(vv);
+                    vv = vv.izquierdo;
+                }
+            }
+            return v.elemento;
         }
     }
 
@@ -68,8 +86,46 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * Agrega un nuevo elemento al árbol. El árbol conserva su orden in-order.
      * @param elemento el elemento a agregar.
      */
-    @Override public void agrega(T elemento) {
-        // Aquí va su código.
+    @Override public void agrega(T elemento)
+    {
+        if (elemento == null)
+            throw new IllegalArgumentException();
+        if (raiz == null)
+        {
+            raiz = nuevoVertice(elemento);
+            ultimoAgregado = raiz;
+            elementos++;
+            return;
+        }
+        agrega(elemento,raiz);
+    }
+
+    private void agrega(T elemento, Vertice vertice)
+    {
+        if (elemento.compareTo(vertice.elemento) <= 0)
+        {
+            if (!vertice.hayIzquierdo())
+            {
+                vertice.izquierdo = nuevoVertice(elemento);
+                vertice.izquierdo.padre = vertice;
+                ultimoAgregado = vertice.izquierdo;
+                elementos++;
+            }
+            else
+                agrega(elemento,vertice.izquierdo);
+        }
+        else
+        {
+            if (!vertice.hayDerecho())
+            {
+                vertice.derecho = nuevoVertice(elemento);
+                vertice.derecho.padre = vertice;
+                ultimoAgregado = vertice.derecho;
+                elementos++;
+            }
+            else
+                agrega(elemento,vertice.derecho);
+        }
     }
 
     /**
@@ -78,8 +134,15 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * conserva su orden in-order.
      * @param elemento el elemento a eliminar.
      */
-    @Override public void elimina(T elemento) {
-        // Aquí va su código.
+    @Override public void elimina(T elemento)
+    {
+        Vertice v = vertice(busca(elemento));
+        if (v == null)
+            return;
+        elementos--;
+        if (v.izquierdo != null && v.derecho != null)
+            v = intercambiaEliminable(v);
+        eliminaVertice(v);
     }
 
     /**
@@ -92,7 +155,9 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      *         de <code>null</code>.
      */
     protected Vertice intercambiaEliminable(Vertice vertice) {
-        // Aquí va su código.
+        Vertice v = maximoEnSubarbol(vertice.izquierdo);
+        vertice.elemento = v.elemento;
+        return v;
     }
 
     /**
@@ -101,10 +166,29 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param vertice el vértice a eliminar; debe tener a lo más un hijo
      *                distinto de <code>null</code>.
      */
-    protected void eliminaVertice(Vertice vertice) {
-        // Aquí va su código.
+    protected void eliminaVertice(Vertice vertice)
+    {
+        Vertice v = hijo(vertice);
+        Vertice vv = vertice.padre;
+        if (vv != null)
+        {
+            if (vv.izquierdo == vertice)
+                vv.izquierdo = v;
+            if (vv.derecho == vertice)
+                vv.derecho = v;
+        }
+        else
+            raiz = v;
+        if (v != null)
+            v.padre = vv;
     }
 
+    private Vertice hijo(Vertice v) {
+      if (v.izquierdo != null)
+          return v.izquierdo;
+      return v.derecho;
+    }
+        
     /**
      * Busca un elemento en el árbol recorriéndolo in-order. Si lo encuentra,
      * regresa el vértice que lo contiene; si no, regresa <code>null</code>.
@@ -113,7 +197,15 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      *         encuentra; <code>null</code> en otro caso.
      */
     @Override public VerticeArbolBinario<T> busca(T elemento) {
-        // Aquí va su código.
+        return busca(raiz,elemento);
+    }
+
+    private VerticeArbolBinario<T> busca(Vertice v, T elemento)
+    {
+        return (v == null || elemento == null) ? null :
+        (elemento.compareTo(v.get()) == 0) ? v :
+        (elemento.compareTo(v.get()) < 0) ? busca(v.izquierdo, elemento)
+                                                       : busca(v.derecho, elemento);
     }
 
     /**
@@ -128,7 +220,15 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      *         elemento al árbol.
      */
     public VerticeArbolBinario<T> getUltimoVerticeAgregado() {
-        // Aquí va su código.
+        return ultimoAgregado;
+    }
+
+    protected Vertice maximoEnSubarbol(Vertice vertice)
+    {
+        if (vertice.derecho == null)
+            return vertice;
+        return maximoEnSubarbol(vertice.derecho);
+        
     }
 
     /**
@@ -137,7 +237,25 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param vertice el vértice sobre el que vamos a girar.
      */
     public void giraDerecha(VerticeArbolBinario<T> vertice) {
-        // Aquí va su código.
+        Vertice v = vertice(vertice);
+        if (!v.hayIzquierdo())
+            return;
+        Vertice nvertice = v.padre;
+        Vertice vv = v.izquierdo;
+        Vertice vderecho = vv.derecho;
+        v.padre = vv;
+        vv.derecho = v;
+        if (vderecho != null)
+        vderecho.padre = v;
+        v.izquierdo = vderecho;
+        vv.padre = nvertice;
+        if (nvertice == null)
+            raiz = vv;
+        else
+            if (nvertice.izquierdo == v)
+                nvertice.izquierdo = vv;
+            else
+                nvertice.derecho = vv;
     }
 
     /**
@@ -145,8 +263,27 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * tiene hijo derecho, el método no hace nada.
      * @param vertice el vértice sobre el que vamos a girar.
      */
-    public void giraIzquierda(VerticeArbolBinario<T> vertice) {
-        // Aquí va su código.
+    public void giraIzquierda(VerticeArbolBinario<T> vertice)
+    {
+        Vertice v = vertice(vertice);
+        if (!v.hayDerecho())
+            return;
+        Vertice nvertice = v.padre;
+        Vertice vv = v.derecho;
+        Vertice vizquierdo = vv.izquierdo;
+        v.padre = vv;
+        vv.izquierdo = v;
+        if (vizquierdo != null)
+            vizquierdo.padre = v;
+        v.derecho = vizquierdo;
+        vv.padre = nvertice;
+        if (nvertice == null)   
+            raiz = vv;
+        else
+            if (nvertice.izquierdo == v)
+                nvertice.izquierdo = vv;
+            else
+                nvertice.derecho = vv;
     }
 
     /**
@@ -155,7 +292,19 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void dfsPreOrder(AccionVerticeArbolBinario<T> accion) {
-        // Aquí va su código.
+        dfsPreOrder(raiz,accion);
+    }
+
+    private void dfsPreOrder(Vertice vertice, AccionVerticeArbolBinario<T> accion)
+    {
+        if (vertice != null)
+        {
+            accion.actua(vertice);
+            dfsPreOrder(vertice.izquierdo,accion);
+            dfsPreOrder(vertice.derecho,accion);
+        }
+        else
+            return;
     }
 
     /**
@@ -164,7 +313,19 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void dfsInOrder(AccionVerticeArbolBinario<T> accion) {
-        // Aquí va su código.
+        dfsInOrder(raiz,accion);
+    }
+
+    private void dfsInOrder(Vertice vertice, AccionVerticeArbolBinario<T> accion)
+    {
+        if (vertice != null)
+        {
+            dfsInOrder(vertice.izquierdo,accion);
+            accion.actua(vertice); 
+            dfsInOrder(vertice.derecho,accion);    
+        }
+        else
+            return;
     }
 
     /**
@@ -173,7 +334,19 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      * @param accion la acción a realizar en cada elemento del árbol.
      */
     public void dfsPostOrder(AccionVerticeArbolBinario<T> accion) {
-        // Aquí va su código.
+        dfsPostOrder(raiz,accion);
+    }
+
+    private void dfsPostOrder(Vertice vertice, AccionVerticeArbolBinario<T> accion)
+    {
+        if (vertice != null)
+        {
+            dfsPostOrder(vertice.izquierdo,accion);
+            dfsPostOrder(vertice.derecho,accion);
+            accion.actua(vertice);
+        }
+        else
+            return;
     }
 
     /**
diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolRojinegro.java b/src/main/java/mx/unam/ciencias/edd/ArbolRojinegro.java
index 3bdf8f5..b359ae9 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolRojinegro.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolRojinegro.java
@@ -31,7 +31,8 @@ public class ArbolRojinegro<T extends Comparable<T>>
          * @param elemento el elemento del vértice.
          */
         public VerticeRojinegro(T elemento) {
-            // Aquí va su código.
+            super(elemento);
+            color = Color.NINGUNO;
         }
 
         /**
@@ -39,7 +40,8 @@ public class ArbolRojinegro<T extends Comparable<T>>
          * @return una representación en cadena del vértice rojinegro.
          */
         public String toString() {
-            // Aquí va su código.
+            return (color == Color.ROJO) ? "R{"+String.valueOf(elemento)+"}":
+            "N{"+String.valueOf(elemento)+"}";
         }
 
         /**
@@ -57,7 +59,7 @@ public class ArbolRojinegro<T extends Comparable<T>>
                 return false;
             @SuppressWarnings("unchecked")
                 VerticeRojinegro vertice = (VerticeRojinegro)objeto;
-            // Aquí va su código.
+            return (color == vertice.color && super.equals(objeto));
         }
     }
 
@@ -84,7 +86,13 @@ public class ArbolRojinegro<T extends Comparable<T>>
      * @return un nuevo vértice rojinegro con el elemento recibido dentro del mismo.
      */
     @Override protected Vertice nuevoVertice(T elemento) {
-        // Aquí va su código.
+        return new VerticeRojinegro(elemento);
+    }
+
+    private VerticeRojinegro verticeRojinegro(VerticeArbolBinario<T> vertice)
+    {
+        VerticeRojinegro v = (VerticeRojinegro)vertice;
+        return v;
     }
 
     /**
@@ -95,7 +103,9 @@ public class ArbolRojinegro<T extends Comparable<T>>
      *         VerticeRojinegro}.
      */
     public Color getColor(VerticeArbolBinario<T> vertice) {
-        // Aquí va su código.
+        if (vertice.getClass() != VerticeRojinegro.class)
+        throw new ClassCastException();
+        return verticeRojinegro(vertice).color; 
     }
 
     /**
@@ -105,7 +115,63 @@ public class ArbolRojinegro<T extends Comparable<T>>
      * @param elemento el elemento a agregar.
      */
     @Override public void agrega(T elemento) {
-        // Aquí va su código.
+        super.agrega(elemento);
+        VerticeRojinegro vrj = (VerticeRojinegro)super.getUltimoVerticeAgregado();
+        vrj.color = Color.ROJO;
+        rebalanceaAgrega(vrj);
+    }
+
+    private void rebalanceaAgrega(VerticeRojinegro vertice)
+    {
+        VerticeRojinegro padre,tio,abuelo,aux;
+        // Caso 1
+        if (!vertice.hayPadre())
+        {
+            vertice.color = Color.NEGRO;
+            return;
+        }
+
+        // Caso 2
+        padre = getPadre(vertice);
+        if (esNegro(padre))
+            return;
+
+        // Caso 3
+        abuelo = getAbuelo(vertice);
+        tio = getTio(vertice);
+        if (esRojo(tio))
+        {
+            tio.color = Color.NEGRO;
+            padre.color = Color.NEGRO;
+            abuelo.color = Color.ROJO;
+            rebalanceaAgrega(abuelo);
+        }
+        else
+        {
+
+        // Caso 4
+        aux = padre;
+        if (abuelo.izquierdo == padre && padre.derecho == vertice)
+        {
+            super.giraIzquierda(padre);
+            padre = vertice;
+            vertice = aux;
+        }
+        if (abuelo.derecho == padre && padre.izquierdo == vertice)
+        {
+            super.giraDerecha(padre);
+            padre = vertice;
+            vertice = aux;
+        }
+
+        // Caso 5
+        padre.color = Color.NEGRO;
+        abuelo.color = Color.ROJO;
+        if (vertice == padre.izquierdo)
+            super.giraDerecha(abuelo);
+        else
+            super.giraIzquierda(abuelo);
+        }
     }
 
     /**
@@ -114,10 +180,236 @@ public class ArbolRojinegro<T extends Comparable<T>>
      * rebalancearlo.
      * @param elemento el elemento a eliminar del árbol.
      */
-    @Override public void elimina(T elemento) {
-        // Aquí va su código.
+    @Override public void elimina(T elemento)
+    {
+        VerticeRojinegro vertice = buscaElemento(verticeRojinegro(super.raiz),elemento);
+        if (vertice == null)
+            return;
+
+        VerticeRojinegro aux = null;
+        if (vertice.hayIzquierdo())
+        {
+            aux = vertice;
+            vertice = intercambiaVertice(verticeRojinegro(vertice.izquierdo));
+            aux.elemento = vertice.elemento;
+            aux = null;
+        }
+
+        if (!vertice.hayIzquierdo() && !vertice.hayDerecho())
+        {
+            vertice.izquierdo = nuevoVertice(null);
+            aux = verticeRojinegro(vertice.izquierdo);
+            aux.padre = vertice;
+            aux.color = Color.NEGRO;
+        }
+
+        VerticeRojinegro hermano = null;
+        if (vertice.hayIzquierdo())
+            hermano = verticeRojinegro(vertice.izquierdo);
+        else
+            hermano = verticeRojinegro(vertice.derecho);
+
+        desconecta(hermano,vertice);
+
+        if (esRojo(hermano) || esRojo(vertice))
+            hermano.color = Color.NEGRO;
+        else
+        {
+            hermano.color = Color.NEGRO;
+            rebalanceaElimina(hermano);
+        }
+
+        if (aux != null)
+        {
+            if (!aux.hayPadre())
+            {
+                super.raiz = null;
+                ultimoAgregado = null;
+                aux = null;
+            }
+            else if (aux.padre.derecho == aux)
+                aux.padre.derecho = null;
+            else
+                aux.padre.izquierdo = null;
+        }
+        elementos--;
     }
 
+    private VerticeRojinegro intercambiaVertice(VerticeRojinegro vertice)
+    {
+        if (vertice.hayDerecho())
+            return intercambiaVertice(verticeRojinegro(vertice.derecho));
+        else
+            return vertice;
+    }
+
+    private void desconecta(VerticeRojinegro hijo, VerticeRojinegro vertice)
+    {
+        if (!vertice.hayPadre())
+        {
+            raiz = hijo;
+            raiz.padre = null;
+            return;
+        }
+        hijo.padre = vertice.padre;
+        if (vertice == vertice.padre.izquierdo)
+        {
+            if (vertice.izquierdo == hijo)
+                vertice.padre.izquierdo = vertice.izquierdo;
+            else
+                vertice.padre.izquierdo = vertice.derecho;
+        }
+        if (vertice == vertice.padre.derecho)
+        {
+            if (vertice.izquierdo == hijo)
+                vertice.padre.derecho = vertice.izquierdo;
+            else
+                vertice.padre.derecho = vertice.derecho;
+        }
+    }
+
+    private VerticeRojinegro buscaElemento(VerticeRojinegro vertice, T elemento)
+    {
+        if (vertice == null)
+        return null;
+        if (elemento.equals(vertice.elemento))
+            return vertice;
+        if (elemento.compareTo(vertice.elemento) < 0)
+            return buscaElemento(verticeRojinegro(vertice.izquierdo), elemento);
+        else
+            return buscaElemento(verticeRojinegro(vertice.derecho), elemento);
+    }
+
+    private VerticeRojinegro getPadre(VerticeRojinegro vertice)
+    {
+        VerticeRojinegro padre = verticeRojinegro(vertice.padre);
+        return padre;
+    }
+
+    private VerticeRojinegro getAbuelo(VerticeRojinegro vertice)
+    {
+        VerticeRojinegro padre = verticeRojinegro(vertice.padre);
+        return verticeRojinegro(padre.padre);
+    }
+
+    private VerticeRojinegro getTio(VerticeRojinegro vertice)
+    {
+        VerticeRojinegro abuelo = getAbuelo(vertice);
+        if (vertice.padre == abuelo.izquierdo)
+            return verticeRojinegro(abuelo.derecho);
+        else
+            return verticeRojinegro(abuelo.izquierdo);
+    }
+
+    private VerticeRojinegro getHermano(VerticeRojinegro vertice)
+    {
+        VerticeRojinegro padre = verticeRojinegro(vertice.padre);
+        if (vertice == padre.izquierdo)
+            return verticeRojinegro(padre.derecho);
+        else
+            return verticeRojinegro(padre.izquierdo);
+    }
+
+    private boolean esNegro(VerticeRojinegro vertice)
+    {
+        return(vertice == null || vertice.color == Color.NEGRO);
+    }
+
+    private boolean esRojo(VerticeRojinegro vertice)
+    {
+        return(vertice != null && vertice.color == Color.ROJO);
+    }
+
+    private void rebalanceaElimina(VerticeRojinegro vertice)
+    {
+        VerticeRojinegro hermano,padre,hijoIzquierdo,hijoDerecho;
+        /* Caso 1
+            v tiene padre null
+        */
+            if (!vertice.hayPadre())
+            {
+                vertice.color = Color.NEGRO;
+                raiz = vertice;
+                return;
+            }
+            padre = getPadre(vertice);
+            hermano = getHermano(vertice);
+
+        /* Caso 2
+            vertice h es rojo y por lo tanto p es negro
+        */
+            if (esRojo(hermano) && esNegro(padre))
+            {
+                padre.color = Color.ROJO;
+                hermano.color = Color.NEGRO;
+                if (vertice == padre.izquierdo)
+                    super.giraIzquierda(padre);
+                else
+                    super.giraDerecha(padre);
+                hermano = getHermano(vertice);
+                padre = getPadre(vertice);
+            }
+            hijoIzquierdo = verticeRojinegro(hermano.izquierdo);
+            hijoDerecho = verticeRojinegro(hermano.derecho);
+
+        /* Caso 3
+            los vertices p,h,hi y hd son negros
+        */
+            if (esNegro(padre) && esNegro(hermano) && esNegro(hijoIzquierdo) && esNegro(hijoDerecho))
+            {
+                hermano.color = Color.ROJO;
+                rebalanceaElimina(padre);
+                return;
+            }
+
+        /* Caso 4
+            vertices h,hi y hd son negros y p es rojo
+        */
+            if (esNegro(hermano) && esNegro(hijoIzquierdo) && esNegro(hijoDerecho) && esRojo(padre))
+            {
+                hermano.color = Color.ROJO;
+                padre.color = Color.NEGRO;
+                return;
+            }
+
+        /* Caso 5
+            v es izquierdo, hi es rojo y hd es negro;
+            o el vértice v es derecho,
+            hi es negro y hd es rojo
+        */
+            if (vertice == padre.izquierdo && esRojo(hijoIzquierdo) && esNegro(hijoDerecho) && esNegro(hermano))
+            {
+                hermano.color = Color.ROJO;
+                hijoIzquierdo.color = Color.NEGRO;
+                super.giraDerecha(hermano);
+            }
+            else if (vertice == padre.derecho && esNegro(hijoIzquierdo) && esRojo(hijoDerecho) && esNegro(hermano))
+            {
+                hermano.color = Color.ROJO;
+                hijoDerecho.color = Color.NEGRO;
+                super.giraIzquierda(hermano);
+            }
+            hermano = getHermano(vertice);
+            hijoIzquierdo = verticeRojinegro(hermano.izquierdo);
+            hijoDerecho = verticeRojinegro(hermano.derecho);
+
+        /* Caso 6
+            v es izquierdo y hd es rojo o v es derecho y hi es rojo
+        */
+            hermano.color = padre.color;
+            padre.color = Color.NEGRO;
+            if (vertice == padre.izquierdo)
+            {
+                hijoDerecho.color = Color.NEGRO;
+                super.giraIzquierda(padre);
+            }
+            else
+            {
+                hijoIzquierdo.color = Color.NEGRO;
+                super.giraDerecha(padre);
+            }
+        }
+
     /**
      * Lanza la excepción {@link UnsupportedOperationException}: los árboles
      * rojinegros no pueden ser girados a la izquierda por los usuarios de la
diff --git a/src/main/java/mx/unam/ciencias/edd/Arreglos.java b/src/main/java/mx/unam/ciencias/edd/Arreglos.java
index 641317c..814e864 100644
--- a/src/main/java/mx/unam/ciencias/edd/Arreglos.java
+++ b/src/main/java/mx/unam/ciencias/edd/Arreglos.java
@@ -16,9 +16,53 @@ public class Arreglos {
      * @param arreglo el arreglo a ordenar.
      * @param comparador el comparador para ordenar el arreglo.
      */
+
     public static <T> void
-    quickSort(T[] arreglo, Comparator<T> comparador) {
-        // Aquí va su código.
+    quickSort(T[] arreglo, Comparator<T> comparador)
+    {
+        aquickSorta(arreglo, comparador);
+    }
+
+    private static <T> void
+    aquickSorta(T[] arreglo, Comparator<T> comparador)
+    {
+        Lista<Integer> lista = new Lista<Integer>();
+        lista.agregaFinal(0);
+        lista.agregaFinal(arreglo.length-1);
+        while (lista.getLongitud() > 0)
+        {
+            int a = lista.eliminaUltimo();
+            int b = lista.eliminaUltimo();
+            if (a - b < 1)
+                continue;
+            int i = b + 1;
+            int j = a;
+            while (i < j)
+                {
+                if (comparador.compare(arreglo[i],arreglo[b]) > 0 && comparador.compare(arreglo[j],arreglo[b]) <= 0)
+                    intercambiapalquick(arreglo,i++,j--);   
+                else if (comparador.compare(arreglo[i],arreglo[b]) <= 0)
+                    i++;
+                else
+                    j--;
+                }
+                if (comparador.compare(arreglo[i],arreglo[b]) > 0)
+                    i--;
+                intercambiapalquick(arreglo,b,i);
+                lista.agregaFinal(b);
+                lista.agregaFinal(i-1);
+                lista.agregaFinal(i+1);
+                lista.agregaFinal(a);
+        }
+    }
+ 
+    private static <T> void intercambiapalquick(T[] arreglo, int i, int j)
+    {
+        if (i == j)
+            return;
+        T aux = arreglo[j];
+        arreglo[j] = arreglo[i];
+        arreglo[i] = aux;
     }
 
     /**
@@ -38,8 +82,26 @@ public class Arreglos {
      * @param comparador el comparador para ordernar el arreglo.
      */
     public static <T> void
-    selectionSort(T[] arreglo, Comparator<T> comparador) {
-        // Aquí va su código.
+    selectionSort(T[] arreglo, Comparator<T> comparador)
+    {
+        int max = arreglo.length;
+        for(int i = 0; i<max; i++)
+        {
+            int min = i;
+            for (int j = i+1; j < max; j++)
+            {
+                if (comparador.compare(arreglo[j], arreglo[min]) < 0)
+                min = j;
+            }
+                intercambiapalselec(arreglo, i, min);
+        }
+    }
+
+    private static <T> void intercambiapalselec (T [] arreglo, int i, int j)
+    {
+        T aux1 = arreglo[i];
+        arreglo[i] = arreglo[j];
+        arreglo[j] = aux1;
     }
 
     /**
@@ -62,8 +124,31 @@ public class Arreglos {
      * @return el índice del elemento en el arreglo, o -1 si no se encuentra.
      */
     public static <T> int
-    busquedaBinaria(T[] arreglo, T elemento, Comparator<T> comparador) {
-        // Aquí va su código.
+    busquedaBinaria(T[] arreglo, T elemento, Comparator<T> comparador)
+    {
+        int i = 0;
+        int j = arreglo.length-1;
+        while(i <= j)
+        {
+            int mitad = j+(i-j)/2;
+            if(comparador.compare(arreglo[mitad], elemento) == 0)
+                return mitad;
+            else if(comparador.compare(arreglo[mitad], elemento) > 0)
+            {
+                if(comparador.compare(arreglo[i], elemento) == 0)
+                    return i;
+                j = mitad - 1;
+                i = i + 1;
+            }
+            else
+            {
+                if (comparador.compare(arreglo[j], elemento) == 0)
+                    return j;
+                j = j - 1;
+                i = i + 1;
+            }
+        }
+        return -1;
     }
 
     /**
diff --git a/src/main/java/mx/unam/ciencias/edd/Cola.java b/src/main/java/mx/unam/ciencias/edd/Cola.java
index 8ab59f9..e9da322 100644
--- a/src/main/java/mx/unam/ciencias/edd/Cola.java
+++ b/src/main/java/mx/unam/ciencias/edd/Cola.java
@@ -9,8 +9,18 @@ public class Cola<T> extends MeteSaca<T> {
      * Regresa una representación en cadena de la cola.
      * @return una representación en cadena de la cola.
      */
-    @Override public String toString() {
-        // Aquí va su código.
+    @Override public String toString()
+    {
+        String s = "";
+        if (this.esVacia())
+            return s;
+        Nodo aux = this.cabeza;
+        while (aux != null)
+        {
+            s += aux.elemento + ",";
+            aux = aux.siguiente;
+        }
+        return s;
     }
 
     /**
@@ -19,7 +29,20 @@ public class Cola<T> extends MeteSaca<T> {
      * @throws IllegalArgumentException si <code>elemento</code> es
      *         <code>null</code>.
      */
-    @Override public void mete(T elemento) {
-        // Aquí va su código.
+    @Override public void mete(T elemento)
+    {
+        if (elemento == null)
+        throw new IllegalArgumentException();
+        Nodo nuevo = new Nodo(elemento);
+        if (this.esVacia())
+        {
+            this.cabeza = nuevo;
+        }
+        else
+        {
+            this.rabo.siguiente = nuevo;
+        }
+        this.rabo = nuevo;
     }
 }
+
diff --git a/src/main/java/mx/unam/ciencias/edd/Conjunto.java b/src/main/java/mx/unam/ciencias/edd/Conjunto.java
index 0795c48..eb555d7 100644
--- a/src/main/java/mx/unam/ciencias/edd/Conjunto.java
+++ b/src/main/java/mx/unam/ciencias/edd/Conjunto.java
@@ -13,16 +13,18 @@ public class Conjunto<T> implements Coleccion<T> {
     /**
      * Crea un nuevo conjunto.
      */
-    public Conjunto() {
-        // Aquí va su código.
+    public Conjunto()
+    {
+        this.conjunto = new Diccionario<>();
     }
 
     /**
      * Crea un nuevo conjunto para un número determinado de elementos.
      * @param n el número tentativo de elementos.
      */
-    public Conjunto(int n) {
-        // Aquí va su código.
+    public Conjunto(int n)
+    {
+        this.conjunto = new Diccionario<>();
     }
 
     /**
@@ -30,8 +32,11 @@ public class Conjunto<T> implements Coleccion<T> {
      * @param elemento el elemento que queremos agregar al conjunto.
      * @throws IllegalArgumentException si el elemento es <code>null</code>.
      */
-    @Override public void agrega(T elemento) {
-        // Aquí va su código.
+    @Override public void agrega(T elemento)
+    {
+        if (elemento == null)
+        throw new IllegalArgumentException();
+        conjunto.agrega(elemento,elemento);
     }
 
     /**
@@ -40,8 +45,11 @@ public class Conjunto<T> implements Coleccion<T> {
      * @return <code>true</code> si el elemento está en el conjunto,
      *         <code>false</code> en otro caso.
      */
-    @Override public boolean contiene(T elemento) {
-        // Aquí va su código.
+    @Override public boolean contiene(T elemento)
+    {
+        if (conjunto.contiene(elemento))
+            return true;
+        return false;
     }
 
     /**
@@ -49,7 +57,8 @@ public class Conjunto<T> implements Coleccion<T> {
      * @param elemento el elemento que queremos eliminar del conjunto.
      */
     @Override public void elimina(T elemento) {
-        // Aquí va su código.
+        if (conjunto.contiene(elemento))
+            conjunto.elimina(elemento);
     }
 
     /**
@@ -58,7 +67,9 @@ public class Conjunto<T> implements Coleccion<T> {
      *         otro caso.
      */
     @Override public boolean esVacia() {
-        // Aquí va su código.
+        if (this.conjunto.esVacia())
+            return true;
+        return false;
     }
 
     /**
@@ -66,14 +77,14 @@ public class Conjunto<T> implements Coleccion<T> {
      * @return el número de elementos en el conjunto.
      */
     @Override public int getElementos() {
-        // Aquí va su código.
+        return this.conjunto.getElementos();
     }
 
     /**
      * Limpia el conjunto de elementos, dejándolo vacío.
      */
     @Override public void limpia() {
-        // Aquí va su código.
+        conjunto.limpia();
     }
 
     /**
@@ -81,8 +92,15 @@ public class Conjunto<T> implements Coleccion<T> {
      * @param conjunto el conjunto que queremos intersectar con éste.
      * @return la intersección del conjunto y el conjunto recibido.
      */
-    public Conjunto<T> interseccion(Conjunto<T> conjunto) {
-        // Aquí va su código.
+    public Conjunto<T> interseccion(Conjunto<T> conjunto)
+    {
+        Conjunto<T> conjunton = new Conjunto<>();
+        for (T e : this.conjunto)
+        {
+            if (conjunto.contiene(e))
+            conjunton.agrega(e);
+        }
+        return conjunton;
     }
 
     /**
@@ -90,16 +108,33 @@ public class Conjunto<T> implements Coleccion<T> {
      * @param conjunto el conjunto que queremos unir con éste.
      * @return la unión del conjunto y el conjunto recibido.
      */
-    public Conjunto<T> union(Conjunto<T> conjunto) {
-        // Aquí va su código.
+    public Conjunto<T> union(Conjunto<T> conjunto)
+    {
+        Conjunto<T> conjunton = new Conjunto<>();
+        for (T e: this.conjunto) 
+                conjunton.agrega(e);
+        for (T e: conjunto) 
+                conjunton.agrega(e);
+        return conjunton;
     }
 
     /**
      * Regresa una representación en cadena del conjunto.
      * @return una representación en cadena del conjunto.
      */
-    @Override public String toString() {
-        // Aquí va su código.
+    @Override public String toString()
+    {
+        String s ="{ ",d ="";
+        Iterator<T> iterador = iterator();
+        while (iterador.hasNext())
+        {
+            T e = iterador.next();
+            if (!iterador.hasNext())
+                d += e;
+            else
+                d += e + ", ";
+        }
+        return s += d + " }";
     }
 
     /**
@@ -112,7 +147,7 @@ public class Conjunto<T> implements Coleccion<T> {
         if (o == null || getClass() != o.getClass())
             return false;
         @SuppressWarnings("unchecked") Conjunto<T> c = (Conjunto<T>)o;
-        // Aquí va su código.
+        return conjunto.equals(c.conjunto);
     }
 
     /**
@@ -120,6 +155,6 @@ public class Conjunto<T> implements Coleccion<T> {
      * @return un iterador para iterar el conjunto.
      */
     @Override public Iterator<T> iterator() {
-        // Aquí va su código.
+        return conjunto.iterator();
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/Diccionario.java b/src/main/java/mx/unam/ciencias/edd/Diccionario.java
index b8c9e24..10524d6 100644
--- a/src/main/java/mx/unam/ciencias/edd/Diccionario.java
+++ b/src/main/java/mx/unam/ciencias/edd/Diccionario.java
@@ -21,7 +21,8 @@ public class Diccionario<K, V> implements Iterable<V> {
 
         /* Construye una nueva entrada. */
         public Entrada(K llave, V valor) {
-            // Aquí va su código.
+            this.llave = llave;
+            this.valor = valor;
         }
     }
 
@@ -36,17 +37,39 @@ public class Diccionario<K, V> implements Iterable<V> {
         /* Construye un nuevo iterador, auxiliándose de las listas del
          * diccionario. */
         public Iterador() {
-            // Aquí va su código.
+          Lista<Entrada> e = null;
+          for(int i = 0; i < entradas.length; i++){
+            if(entradas[i] != null){
+              indice = i;
+              e = entradas[i];
+              break;
+            }
+           }
+          if(e != null)
+            this.iterador = e.iterator();
+          else
+            this.iterador = null;
         }
 
         /* Nos dice si hay una siguiente entrada. */
         public boolean hasNext() {
-            // Aquí va su código.
+          return (iterador != null);
         }
 
         /* Regresa la siguiente entrada. */
         public Entrada siguiente() {
-            // Aquí va su código.
+          Entrada e = iterador.next();
+          if(!iterador.hasNext()){
+              iterador = null;
+              for(int i = indice + 1; i < entradas.length; i++){
+                if(entradas[i] != null){
+                    indice = i;
+                    iterador = entradas[i].iterator();
+                    break;
+                }
+              }
+          }
+          return e;
         }
     }
 
@@ -56,7 +79,7 @@ public class Diccionario<K, V> implements Iterable<V> {
 
         /* Regresa el siguiente elemento. */
         @Override public K next() {
-            // Aquí va su código.
+          return this.siguiente().llave;
         }
     }
 
@@ -66,7 +89,7 @@ public class Diccionario<K, V> implements Iterable<V> {
 
         /* Regresa el siguiente elemento. */
         @Override public V next() {
-            // Aquí va su código.
+            return this.siguiente().valor;
         }
     }
 
@@ -124,7 +147,16 @@ public class Diccionario<K, V> implements Iterable<V> {
      * @param dispersor el dispersor a utilizar.
      */
     public Diccionario(int capacidad, Dispersor<K> dispersor) {
-        // Aquí va su código.
+        this.dispersor = dispersor;
+        if (capacidad < MINIMA_CAPACIDAD)
+        	capacidad = MINIMA_CAPACIDAD;
+        int a = 1;
+        while (a < capacidad*2)
+        {
+        	a*=2;
+        }
+        entradas = nuevoArreglo(a);
+        elementos = 0;
     }
 
     /**
@@ -135,8 +167,60 @@ public class Diccionario<K, V> implements Iterable<V> {
      * @param valor el valor a agregar.
      * @throws IllegalArgumentException si la llave o el valor son nulos.
      */
-    public void agrega(K llave, V valor) {
-        // Aquí va su código.
+    public void agrega(K llave, V valor)
+    {
+        if (llave == null || valor == null)
+        throw new IllegalArgumentException();
+    	int indice = dispersor.dispersa(llave)&mascara();
+    	if (entradas[indice] == null)
+    	{
+    		Lista<Entrada> entrada = new Lista<>();
+    		entrada.agrega(new Entrada(llave,valor));
+    		entradas[indice] = entrada;
+    		elementos++;
+    	}
+    	else
+    	{
+    		boolean l = false;
+    		for (Entrada entrada: entradas[indice])
+    		{
+    			if (l)
+    				break;
+    			if (entrada.llave.equals(llave))
+    			{
+    				l = true;
+    				entrada.valor = valor;
+    			}
+    		}
+    		if (!l)
+    		{
+    			entradas[indice].agrega(new Entrada(llave,valor));
+    			elementos++;
+    		}
+    	}
+    	if (carga() >= MAXIMA_CARGA)
+    	{
+    		Lista<Entrada> entrada = new Lista<>();
+    		for (int i=0; i<entradas.length; i++)
+    		{
+    			if (entradas[i] != null)
+    			{
+    				for (Entrada ent: entradas[i])
+    					entrada.agrega(ent);
+    			}
+    		}
+    		entradas = nuevoArreglo(entradas.length*2);
+    		elementos = 0;
+    		for (Entrada entr: entrada)
+    		{
+    			agrega(entr.llave,entr.valor);
+    		}
+    	}
+    }
+
+    private int mascara()
+    {
+    	return (entradas.length-1);
     }
 
     /**
@@ -146,8 +230,17 @@ public class Diccionario<K, V> implements Iterable<V> {
      * @throws IllegalArgumentException si la llave es nula.
      * @throws NoSuchElementException si la llave no está en el diccionario.
      */
-    public V get(K llave) {
-        // Aquí va su código.
+    public V get(K llave)
+    {
+        if (llave == null)
+        throw new IllegalArgumentException();
+    	if (!contiene(llave))
+    	throw new NoSuchElementException();
+    	int indice = dispersor.dispersa(llave)&mascara();
+    	for (Entrada entrada: entradas[indice])
+    		if (entrada.llave.equals(llave))
+    			return entrada.valor;
+    	throw new NoSuchElementException();
     }
 
     /**
@@ -156,8 +249,17 @@ public class Diccionario<K, V> implements Iterable<V> {
      * @return <code>true</code> si la llave está en el diccionario,
      *         <code>false</code> en otro caso.
      */
-    public boolean contiene(K llave) {
-        // Aquí va su código.
+    public boolean contiene(K llave)
+    {
+        if (llave == null)
+        	return false;
+        int indice = dispersor.dispersa(llave)&mascara();
+        if (entradas[indice] == null)
+    	    return false;
+    	for (Entrada entrada: entradas[indice])
+    		if (entrada.llave.equals(llave))
+    			return true;
+    	return false;
     }
 
     /**
@@ -167,16 +269,37 @@ public class Diccionario<K, V> implements Iterable<V> {
      * @throws NoSuchElementException si la llave no se encuentra en
      *         el diccionario.
      */
-    public void elimina(K llave) {
-        // Aquí va su código.
+    public void elimina(K llave)
+    {
+        if (llave == null)
+        throw new IllegalArgumentException();
+    	if (!contiene(llave))
+    	throw new NoSuchElementException();
+    	int indice = dispersor.dispersa(llave)&mascara();
+    	for (Entrada entrada: entradas[indice])
+    	{
+    		if (entrada.llave.equals(llave))
+    		{
+    			entradas[indice].elimina(entrada);
+    			elementos--;
+    			break;
+    		}
+    	}
+    	if (entradas[indice].getLongitud() == 0)
+    		entradas[indice] = null;
     }
 
     /**
      * Nos dice cuántas colisiones hay en el diccionario.
      * @return cuántas colisiones hay en el diccionario.
      */
-    public int colisiones() {
-        // Aquí va su código.
+    public int colisiones()
+    {
+        int c = 0;
+        for (int i=0; i<entradas.length; i++) 
+        	if (entradas[i] != null)
+        		c += entradas[i].getLongitud()-1;
+        return c;
     }
 
     /**
@@ -184,16 +307,24 @@ public class Diccionario<K, V> implements Iterable<V> {
      * en el diccionario.
      * @return el máximo número de colisiones para una misma llave.
      */
-    public int colisionMaxima() {
-        // Aquí va su código.
+    public int colisionMaxima()
+    {
+        int c = 0;
+        for (int i=0; i<entradas.length; i++)
+        	if (entradas[i] != null) 
+        		if (entradas[i].getLongitud()-1>c)
+        				c = entradas[i].getLongitud()-1;
+        return c;	
     }
 
     /**
      * Nos dice la carga del diccionario.
      * @return la carga del diccionario.
      */
-    public double carga() {
-        // Aquí va su código.
+    public double carga()
+    {
+        double carga = (getElementos()+0.0)/(double)entradas.length;
+        return carga;
     }
 
     /**
@@ -201,7 +332,7 @@ public class Diccionario<K, V> implements Iterable<V> {
      * @return el número de entradas en el diccionario.
      */
     public int getElementos() {
-        // Aquí va su código.
+        return this.elementos;
     }
 
     /**
@@ -210,14 +341,16 @@ public class Diccionario<K, V> implements Iterable<V> {
      *         en otro caso.
      */
     public boolean esVacia() {
-        // Aquí va su código.
+        return (elementos == 0);
     }
 
     /**
      * Limpia el diccionario de elementos, dejándolo vacío.
      */
-    public void limpia() {
-        // Aquí va su código.
+    public void limpia()
+    {
+        nuevoArreglo(MINIMA_CAPACIDAD);
+        elementos = 0;
     }
 
     /**
@@ -225,7 +358,22 @@ public class Diccionario<K, V> implements Iterable<V> {
      * @return una representación en cadena del diccionario.
      */
     @Override public String toString() {
-        // Aquí va su código.
+        String s = "{";
+        if (!esVacia())
+            s+=" ";
+        for (int i=0; i<entradas.length; i++)
+        {
+            if (entradas[i] != null)
+            {
+                for (Entrada entrada: entradas[i])
+                {
+                    s += "'" + entrada.llave + "'" + ": ";
+                    s += "'" + entrada.valor + "'" + ", ";
+                }
+            }
+        }
+        s += "}";
+        return s;
     }
 
     /**
@@ -240,7 +388,20 @@ public class Diccionario<K, V> implements Iterable<V> {
             return false;
         @SuppressWarnings("unchecked") Diccionario<K, V> d =
             (Diccionario<K, V>)o;
-        // Aquí va su código.
+        if (getElementos() != d.getElementos())
+            return false;
+        for (int i=0; i<entradas.length; i++)
+        {
+            if (entradas[i] != null)
+            {
+                for (Entrada entrada: entradas[i])
+                {
+                    if (!d.contiene(entrada.llave) || !d.get(entrada.llave).equals(get(entrada.llave)))
+                        return false;
+                }
+            }
+        }
+        return true;
     }
 
     /**
@@ -261,3 +422,4 @@ public class Diccionario<K, V> implements Iterable<V> {
         return new IteradorValores();
     }
 }
+
diff --git a/src/main/java/mx/unam/ciencias/edd/Dispersores.java b/src/main/java/mx/unam/ciencias/edd/Dispersores.java
index 0e35435..492ef3e 100644
--- a/src/main/java/mx/unam/ciencias/edd/Dispersores.java
+++ b/src/main/java/mx/unam/ciencias/edd/Dispersores.java
@@ -13,8 +13,28 @@ public class Dispersores {
      * @param llave la llave a dispersar.
      * @return la dispersión de XOR de la llave.
      */
-    public static int dispersaXOR(byte[] llave) {
-        // Aquí va su código.
+    public static int dispersaXOR(byte[] llave)
+    {
+        int l = llave.length;
+        int r = 0;
+        int i = 0;
+
+        while (l > 3)
+        {
+            r ^= combina(llave[i],llave[i+1],llave[i+2],llave[i+3]);
+            i += 4;
+            l -= 4;
+        }
+        switch (l)
+        {
+            case 1: r ^= combina(llave[i],(byte) 0,(byte) 0,(byte) 0);
+            break;
+            case 2: r ^= combina(llave[i],llave[i+1],(byte) 0,(byte) 0);
+            break;
+            case 3: r ^= combina(llave[i],llave[i+1],llave[i+2],(byte) 0);
+            break;
+        }
+        return  r;
     }
 
     /**
@@ -22,8 +42,64 @@ public class Dispersores {
      * @param llave la llave a dispersar.
      * @return la dispersión de Bob Jenkins de la llave.
      */
-    public static int dispersaBJ(byte[] llave) {
-        // Aquí va su código.
+    public static int dispersaBJ(byte[] llave)
+    {
+        int a = 0x9e3779b9;
+        int b = a;
+        int c = 0xffffffff;
+        int i = 0;
+        int disponible = llave.length;
+        int j = disponible;
+        while (disponible >= 12)
+        {
+            a += ((llave[i] & 0xFF) | ((llave[i+1] & 0xFF) << 8) | (llave[i+2] & 0xFF) << 16 | (llave[i+3] & 0xFF) << 24);
+            b += ((llave[i+4] & 0xFF) | ((llave[i+5] & 0xFF) << 8) | (llave[i+6] & 0xFF) << 16 | (llave[i+7] & 0xFF) << 24);
+            c += ((llave[i+8] & 0xFF) | ((llave[i+9] & 0xFF) << 8) | (llave[i+10] & 0xFF) << 16 | (llave[i+11] & 0xFF) << 24);
+
+            int [] arry = mezcla(a,b,c);
+            a = arry[0];
+            b = arry[1]; 
+            c = arry[2];
+            i += 12;
+            disponible -= 12;
+        }
+
+        c += j;
+        switch (disponible)
+        {
+            case 11: c += ((llave[i+10] & 0xFF) << 24);
+            case 10: c += ((llave[i+9] & 0xFF) << 16);
+            case  9: c += ((llave[i+8] & 0xFF) << 8);
+            case  8: b += ((llave[i+7] & 0xFF) << 24);
+            case  7: b += ((llave[i+6] & 0xFF) << 16);
+            case  6: b += ((llave[i+5] & 0xFF) << 8);
+            case  5: b += (llave[i+4] & 0xFF);       
+            case  4: a += ((llave[i+3] & 0xFF) << 24);
+            case  3: a += ((llave[i+2] & 0xFF) << 16);
+            case  2: a += ((llave[i+1] & 0xFF) << 8);
+            case  1: a += (llave[i] & 0xFF);
+        }
+
+        int [] arry = mezcla(a,b,c);
+        return arry[2];
+    }
+
+    private static int [] mezcla(int a,int b,int c)
+    {
+        int [] arry = new int [3];
+        a -= b; a -= c; a ^= (c >>> 13);
+        b -= c; b -= a; b ^= (a <<  8);
+        c -= a; c -= b; c ^= (b >>> 13);
+        a -= b; a -= c; a ^= (c >>> 12);
+        b -= c; b -= a; b ^= (a <<  16);
+        c -= a; c -= b; c ^= (b >>> 5);
+        a -= b; a -= c; a ^= (c >>> 3);
+        b -= c; b -= a; b ^= (a <<  10);
+        c -= a; c -= b; c ^= (b >>> 15);
+        arry[0] = a;
+        arry[1] = b;
+        arry[2] = c;
+        return arry;
     }
 
     /**
@@ -31,7 +107,18 @@ public class Dispersores {
      * @param llave la llave a dispersar.
      * @return la dispersión de Daniel Bernstein de la llave.
      */
-    public static int dispersaDJB(byte[] llave) {
-        // Aquí va su código.
+    public static int dispersaDJB(byte[] llave)
+    {
+        int h = 5381;
+        for (int i=0; i<llave.length; i++)
+        {
+            h += (h << 5) + (llave[i] & 0xFF);
+        }
+        return h;  
+    }
+
+    private static int combina(byte a,byte b,byte c,byte d) 
+    {              
+        return ((a & 0xFF) << 24) | ((b & 0xFF) << 16) | ((c & 0xFF) << 8) | (d & 0xFF);
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/Grafica.java b/src/main/java/mx/unam/ciencias/edd/Grafica.java
index 07aaa0a..bf3bee2 100644
--- a/src/main/java/mx/unam/ciencias/edd/Grafica.java
+++ b/src/main/java/mx/unam/ciencias/edd/Grafica.java
@@ -17,17 +17,17 @@ public class Grafica<T> implements Coleccion<T> {
 
         /* Construye un nuevo iterador, auxiliándose de la lista de vértices. */
         public Iterador() {
-            // Aquí va su código.
+            this.iterador = vertices.iterator();
         }
 
         /* Nos dice si hay un siguiente elemento. */
         @Override public boolean hasNext() {
-            // Aquí va su código.
+            return this.iterador.hasNext();
         }
 
         /* Regresa el siguiente elemento. */
         @Override public T next() {
-            // Aquí va su código.
+            return this.iterador.next().get();
         }
     }
 
@@ -43,48 +43,55 @@ public class Grafica<T> implements Coleccion<T> {
         public double distancia;
         /* El índice del vértice. */
         public int indice;
-        /* El diccionario de vecinos del vértice. */
-        public Diccionario<T, Vecino> vecinos;
+        /* La lista de vecinos del vértice. */
+        public Lista<Vecino> vecinos;
 
         /* Crea un nuevo vértice a partir de un elemento. */
-        public Vertice(T elemento) {
-            // Aquí va su código.
+        public Vertice(T elemento)
+        {
+            this.elemento = elemento;
+            this.color = Color.NINGUNO;
+            this.vecinos = new Lista<Vecino>();
         }
 
         /* Regresa el elemento del vértice. */
         @Override public T get() {
-            // Aquí va su código.
+            return this.elemento;
         }
 
         /* Regresa el grado del vértice. */
         @Override public int getGrado() {
-            // Aquí va su código.
+            return this.vecinos.getElementos();
         }
 
         /* Regresa el color del vértice. */
         @Override public Color getColor() {
-            // Aquí va su código.
+            return this.color;
         }
 
         /* Regresa un iterable para los vecinos. */
         @Override public Iterable<? extends VerticeGrafica<T>> vecinos() {
-            // Aquí va su código.
+            return this.vecinos;
         }
 
         /* Define el índice del vértice. */
         @Override public void setIndice(int indice) {
-            // Aquí va su código.
+            this.indice = indice;
         }
 
         /* Regresa el índice del vértice. */
         @Override public int getIndice() {
-            // Aquí va su código.
+            return this.indice;
         }
 
         /* Compara dos vértices por distancia. */
         @Override public int compareTo(Vertice vertice) {
-            // Aquí va su código.
-        }
+            if (distancia > vertice.distancia)
+                return 1;
+            else if (distancia < vertice.distancia)
+                return -1;
+            return 0;
+        }       
     }
 
     /* Clase interna privada para vértices vecinos. */
@@ -98,27 +105,28 @@ public class Grafica<T> implements Coleccion<T> {
         /* Construye un nuevo vecino con el vértice recibido como vecino y el
          * peso especificado. */
         public Vecino(Vertice vecino, double peso) {
-            // Aquí va su código.
+            this.vecino = vecino;
+            this.peso = peso;
         }
 
         /* Regresa el elemento del vecino. */
         @Override public T get() {
-            // Aquí va su código.
+            return this.vecino.elemento;
         }
 
         /* Regresa el grado del vecino. */
         @Override public int getGrado() {
-            // Aquí va su código.
+            return this.vecino.getGrado();
         }
 
         /* Regresa el color del vecino. */
         @Override public Color getColor() {
-            // Aquí va su código.
+            return this.vecino.getColor();
         }
 
         /* Regresa un iterable para los vecinos del vecino. */
         @Override public Iterable<? extends VerticeGrafica<T>> vecinos() {
-            // Aquí va su código.
+            return this.vecino.vecinos;
         }
     }
 
@@ -131,7 +139,7 @@ public class Grafica<T> implements Coleccion<T> {
     }
 
     /* Vértices. */
-    private Diccionario<T, Vertice> vertices;
+    private Lista<Vertice> vertices;
     /* Número de aristas. */
     private int aristas;
 
@@ -139,7 +147,8 @@ public class Grafica<T> implements Coleccion<T> {
      * Constructor único.
      */
     public Grafica() {
-        // Aquí va su código.
+        this.vertices = new Lista<>();
+        this.aristas = 0;
     }
 
     /**
@@ -148,7 +157,7 @@ public class Grafica<T> implements Coleccion<T> {
      * @return el número de elementos en la gráfica.
      */
     @Override public int getElementos() {
-        // Aquí va su código.
+        return this.vertices.getLongitud();
     }
 
     /**
@@ -156,7 +165,7 @@ public class Grafica<T> implements Coleccion<T> {
      * @return el número de aristas.
      */
     public int getAristas() {
-        // Aquí va su código.
+        return this.aristas;
     }
 
     /**
@@ -166,7 +175,9 @@ public class Grafica<T> implements Coleccion<T> {
      *         la gráfica.
      */
     @Override public void agrega(T elemento) {
-        // Aquí va su código.
+        if (elemento == null || this.contiene(elemento))
+        throw new IllegalArgumentException();
+        vertices.agrega(new Vertice(elemento));
     }
 
     /**
@@ -179,7 +190,16 @@ public class Grafica<T> implements Coleccion<T> {
      *         igual a b.
      */
     public void conecta(T a, T b) {
-        // Aquí va su código.
+        if (!contiene(a) || !contiene(b))
+        throw new NoSuchElementException();
+        if (a.equals(b) || sonVecinos(a,b))
+        throw new IllegalArgumentException();
+
+        Vertice va = (Vertice) vertice(a);
+        Vertice vb = (Vertice) vertice(b);
+        va.vecinos.agrega(new Vecino(vb,1));
+        vb.vecinos.agrega(new Vecino(va,1));
+        aristas++;
     }
 
     /**
@@ -193,7 +213,16 @@ public class Grafica<T> implements Coleccion<T> {
      *         igual a b, o si el peso es no positivo.
      */
     public void conecta(T a, T b, double peso) {
-        // Aquí va su código.
+        if (!contiene(a) || !contiene(b))
+        throw new NoSuchElementException();
+        if (a.equals(b) || sonVecinos(a,b) || peso < 0)
+        throw new IllegalArgumentException();
+
+        Vertice va = (Vertice) vertice(a);
+        Vertice vb = (Vertice) vertice(b);
+        va.vecinos.agrega(new Vecino(vb,peso));
+        vb.vecinos.agrega(new Vecino(va,peso));
+        aristas++;
     }
 
     /**
@@ -205,7 +234,22 @@ public class Grafica<T> implements Coleccion<T> {
      * @throws IllegalArgumentException si a o b no están conectados.
      */
     public void desconecta(T a, T b) {
-        // Aquí va su código.
+        if (!contiene(a) || !contiene(b))
+        throw new NoSuchElementException();
+        if (!sonVecinos(a,b))
+        throw new IllegalArgumentException();
+
+        Vertice va = (Vertice) vertice(a);
+        Vertice vb = (Vertice) vertice(b);
+        Vecino vea = null, veb = null;
+        for (Vecino vecino : va.vecinos)
+        {
+            if (vecino.vecino.equals(vb))
+                vea = vecino;
+        }
+        va.vecinos.elimina(vea);
+        vb.vecinos.elimina(veb);
+        aristas--;
     }
 
     /**
@@ -214,7 +258,27 @@ public class Grafica<T> implements Coleccion<T> {
      *         <code>false</code> en otro caso.
      */
     @Override public boolean contiene(T elemento) {
-        // Aquí va su código.
+        for (Vertice vertice : vertices)
+        {
+            if (vertice.get().equals(elemento))
+            return true;
+        }
+        return false;
+    }
+
+    /**
+     * Método auxiliar para búsqueda de vértices.
+     * @param e elemento a buscar
+     * @return el vértice con el elemento si lo encuentra.
+     */
+    private Vertice busca(T elemento)
+    {
+        for (Vertice vertice : vertices)
+        {
+            if (vertice.get().equals(elemento))
+            return vertice;
+        }
+        return null;
     }
 
     /**
@@ -224,8 +288,23 @@ public class Grafica<T> implements Coleccion<T> {
      * @throws NoSuchElementException si el elemento no está contenido en la
      *         gráfica.
      */
-    @Override public void elimina(T elemento) {
-        // Aquí va su código.
+    @Override public void elimina(T elemento)
+    {
+        if (!contiene(elemento))
+        throw new NoSuchElementException();
+        Vertice v = (Vertice) vertice(elemento);
+        for (Vertice vertice : vertices)
+        {
+            for (Vecino vecino : vertice.vecinos)
+            { 
+                if (vecino.vecino.equals(v))
+                {
+                    vertice.vecinos.elimina(vecino);
+                    aristas--;
+                }
+            }
+        }
+        vertices.elimina(v);
     }
 
     /**
@@ -236,8 +315,18 @@ public class Grafica<T> implements Coleccion<T> {
      * @return <code>true</code> si a y b son vecinos, <code>false</code> en otro caso.
      * @throws NoSuchElementException si a o b no son elementos de la gráfica.
      */
-    public boolean sonVecinos(T a, T b) {
-        // Aquí va su código.
+    public boolean sonVecinos(T a, T b)
+    {
+        if (!contiene(a) || !contiene(b))
+        throw new NoSuchElementException();
+        Vertice va = (Vertice) vertice(a);
+        Vertice vb = (Vertice) vertice(b);
+        for (Vecino vecino : va.vecinos)
+        {
+          if (vecino.vecino.equals(vb))
+            return true;
+        }
+        return false;
     }
 
     /**
@@ -250,8 +339,20 @@ public class Grafica<T> implements Coleccion<T> {
      * @throws NoSuchElementException si a o b no son elementos de la gráfica.
      * @throws IllegalArgumentException si a o b no están conectados.
      */
-    public double getPeso(T a, T b) {
-        // Aquí va su código.
+    public double getPeso(T a, T b)
+    {
+        if (!contiene(a) || !contiene(b))
+        throw new NoSuchElementException();
+        if (!sonVecinos(a,b))
+        throw new IllegalArgumentException();
+        Vertice c = (Vertice) vertice(a);
+        Vertice d = (Vertice) vertice(b);
+        for (Vecino vecino : c.vecinos)
+        {
+            if (vecino.vecino.equals(d))
+                return vecino.peso;
+        }
+        return -1;
     }
 
     /**
@@ -266,7 +367,22 @@ public class Grafica<T> implements Coleccion<T> {
      *         es menor o igual que cero.
      */
     public void setPeso(T a, T b, double peso) {
-        // Aquí va su código.
+        if (!contiene(a) || !contiene(b))
+        throw new NoSuchElementException();
+        if (a.equals(b) || !sonVecinos(a,b) || peso <= 0)
+        throw new IllegalArgumentException();
+        Vertice c = busca(a);
+        Vertice d = busca(b);
+        for (Vecino vecinoa : c.vecinos)
+        {
+            if (vecinoa.vecino.equals(d))
+                vecinoa.peso = peso;
+        }
+        for (Vecino vecinob : d.vecinos)
+        {
+            if (vecinob.vecino.equals(c))
+                vecinob.peso = peso;
+        }
     }
 
     /**
@@ -276,7 +392,9 @@ public class Grafica<T> implements Coleccion<T> {
      * @return el vértice correspondiente el elemento recibido.
      */
     public VerticeGrafica<T> vertice(T elemento) {
-        // Aquí va su código.
+        if(!contiene(elemento))
+        throw new NoSuchElementException();
+        return busca(elemento);
     }
 
     /**
@@ -285,8 +403,20 @@ public class Grafica<T> implements Coleccion<T> {
      * @param color el nuevo color del vértice.
      * @throws IllegalArgumentException si el vértice no es válido.
      */
-    public void setColor(VerticeGrafica<T> vertice, Color color) {
-        // Aquí va su código.
+    public void setColor(VerticeGrafica<T> vertice, Color color)
+    {
+        if (vertice == null || (vertice.getClass() != Vertice.class && vertice.getClass() != Vecino.class))
+        throw new IllegalArgumentException();
+        if (vertice.getClass() == Vertice.class)
+        {
+            Vertice v = (Vertice)vertice;
+            v.color = color;
+        }
+        if (vertice.getClass() == Vecino.class)
+        {
+            Vecino v = (Vecino)vertice;
+            v.vecino.color = color;
+        }
     }
 
     /**
@@ -294,8 +424,31 @@ public class Grafica<T> implements Coleccion<T> {
      * @return <code>true</code> si la gráfica es conexa, <code>false</code> en
      *         otro caso.
      */
-    public boolean esConexa() {
-        // Aquí va su código.
+    public boolean esConexa()
+    {
+        for (Vertice vertice : vertices)
+        vertice.color = Color.ROJO;
+        Cola<Vertice> cola = new Cola<Vertice>();
+        cola.mete(vertices.getPrimero());
+        vertices.getPrimero().color = Color.NEGRO;
+        while (!cola.esVacia())
+        {
+            Vertice v = cola.saca();
+            for (Vecino vecino : v.vecinos)
+            {
+                if (vecino.vecino.color == Color.ROJO)
+                {
+                    vecino.vecino.color = Color.NEGRO;
+                    cola.mete(vecino.vecino);
+                }
+            }
+        }
+        for (Vertice vertice : vertices)
+        {
+            if (vertice.color != Color.NEGRO)
+                return false;
+        }
+            return true;
     }
 
     /**
@@ -304,7 +457,8 @@ public class Grafica<T> implements Coleccion<T> {
      * @param accion la acción a realizar.
      */
     public void paraCadaVertice(AccionVerticeGrafica<T> accion) {
-        // Aquí va su código.
+        for (Vertice vertice : vertices)
+            accion.actua(vertice);
     }
 
     /**
@@ -317,8 +471,9 @@ public class Grafica<T> implements Coleccion<T> {
      * @param accion la acción a realizar.
      * @throws NoSuchElementException si el elemento no está en la gráfica.
      */
-    public void bfs(T elemento, AccionVerticeGrafica<T> accion) {
-        // Aquí va su código.
+    public void bfs(T elemento, AccionVerticeGrafica<T> accion)
+    {
+        recorrido(elemento, accion, new Cola<Grafica<T>.Vertice>());
     }
 
     /**
@@ -331,8 +486,32 @@ public class Grafica<T> implements Coleccion<T> {
      * @param accion la acción a realizar.
      * @throws NoSuchElementException si el elemento no está en la gráfica.
      */
-    public void dfs(T elemento, AccionVerticeGrafica<T> accion) {
-        // Aquí va su código.
+    public void dfs(T elemento, AccionVerticeGrafica<T> accion)
+    {
+        recorrido(elemento, accion, new Pila<Grafica<T>.Vertice>());
+    }
+
+    private void recorrido(T elemento, AccionVerticeGrafica<T> accion, MeteSaca<Grafica<T>.Vertice> metesaca)
+    {
+        if (!contiene(elemento))
+        throw new NoSuchElementException();
+        Vertice v = (Vertice) vertice(elemento);
+        metesaca.mete(v);
+        while (!metesaca.esVacia())
+        {
+            Vertice vv = metesaca.saca();
+            setColor(vv,Color.ROJO);
+            accion.actua(vv);
+            for (Vecino vecino : vv.vecinos)
+            {
+                if (vecino.vecino.color != Color.ROJO)
+                {
+                    setColor(vecino,Color.ROJO);
+                    metesaca.mete(vecino.vecino);
+                }
+            }
+        }
+        this.paraCadaVertice(vertice -> this.setColor(vertice,Color.NINGUNO));
     }
 
     /**
@@ -341,22 +520,43 @@ public class Grafica<T> implements Coleccion<T> {
      *         otro caso.
      */
     @Override public boolean esVacia() {
-        // Aquí va su código.
+        return this.vertices.esVacia();
     }
 
     /**
      * Limpia la gráfica de vértices y aristas, dejándola vacía.
      */
     @Override public void limpia() {
-        // Aquí va su código.
+        this.vertices.limpia();
+        this.aristas = 0;
     }
 
     /**
      * Regresa una representación en cadena de la gráfica.
      * @return una representación en cadena de la gráfica.
      */
-    @Override public String toString() {
-        // Aquí va su código.
+    @Override public String toString()
+    {
+        Lista<T> l = new Lista<T>();
+        for (Vertice vertice : vertices)
+           vertice.color = Color.ROJO;
+        String s = "{";
+        String a = "{";
+        for (Vertice vertice : vertices)
+        {
+            s += vertice.elemento + ", ";
+            for (Vecino vecino : vertice.vecinos)
+            {
+                if (vecino.getColor() == Color.ROJO)
+                    a += "(" + vertice.get() + ", " + vecino.get() + "), ";
+                vertice.color = Color.NEGRO;
+            }
+            l.agrega(vertice.elemento);
+        }
+
+        for (Vertice vertice : vertices)
+           vertice.color = Color.NINGUNO;
+        return s + "}, " + a + "}";
     }
 
     /**
@@ -369,7 +569,27 @@ public class Grafica<T> implements Coleccion<T> {
         if (objeto == null || getClass() != objeto.getClass())
             return false;
         @SuppressWarnings("unchecked") Grafica<T> grafica = (Grafica<T>)objeto;
-        // Aquí va su código.
+        if (getElementos() != grafica.getElementos() || (aristas != grafica.aristas))
+          return false;
+        for (Vertice vertice : vertices)
+        {
+            vertice.color = Color.ROJO;
+            if (!grafica.contiene(vertice.elemento))
+            return false;
+        }
+        for (Vertice vertice : vertices)
+        {
+            for (Vecino vecino : vertice.vecinos)
+            {
+                if (vecino.getColor() == Color.ROJO)
+                {
+                    if (!grafica.sonVecinos(vecino.get(),vertice.elemento))
+                        return false;
+                }
+            }
+            vertice.color = Color.NEGRO;
+        }
+        return true;
     }
 
     /**
@@ -392,8 +612,48 @@ public class Grafica<T> implements Coleccion<T> {
      * @throws NoSuchElementException si alguno de los dos elementos no está en
      *         la gráfica.
      */
-    public Lista<VerticeGrafica<T>> trayectoriaMinima(T origen, T destino) {
-        // Aquí va su código.
+    public Lista<VerticeGrafica<T>> trayectoriaMinima(T origen, T destino)
+    {
+        if (!contiene(origen) || !contiene(destino))
+        throw new NoSuchElementException();
+        Lista<VerticeGrafica<T>> l = new Lista<VerticeGrafica<T>>();
+        Cola<Vertice> cola = new Cola<Vertice>();
+        Vertice a = busca(origen);
+        Vertice b = busca(destino);
+        if (origen.equals(destino))
+        {
+            l.agrega(a);
+            return l;
+        }
+        for (Vertice vertice : vertices)
+            vertice.distancia = -1;
+            a.distancia = 0;
+            cola.mete(a);
+            while (!cola.esVacia())
+            {
+                a = cola.saca();
+                for (Vecino vecino : a.vecinos)
+                {
+                    if (vecino.vecino.distancia == -1)
+                    {
+                        vecino.vecino.distancia = a.distancia +1;
+                        cola.mete(vecino.vecino);
+                    }
+                }
+            }
+            if (b.distancia == -1)
+                return l;
+            l.agrega(b);
+                while (!a.elemento.equals(origen)) 
+                    for (Vecino vecino : a.vecinos)
+                    {
+                        if (a.distancia == vecino.vecino.distancia +1)
+                        {
+                            l.agrega(vecino.vecino);
+                            a = vecino.vecino;
+                        }
+                    }
+        return l.reversa();
     }
 
     /**
@@ -407,7 +667,43 @@ public class Grafica<T> implements Coleccion<T> {
      * @throws NoSuchElementException si alguno de los dos elementos no está en
      *         la gráfica.
      */
-    public Lista<VerticeGrafica<T>> dijkstra(T origen, T destino) {
-        // Aquí va su código.
+    public Lista<VerticeGrafica<T>> dijkstra(T origen, T destino)
+    {
+        if (!contiene(origen) || !contiene(destino))
+        throw new NoSuchElementException();
+        Lista<VerticeGrafica<T>> l = new Lista<VerticeGrafica<T>>();
+        MonticuloMinimo<Vertice> monticulomin = new MonticuloMinimo<Vertice>(vertices);
+        Vertice a = (Vertice) vertice(origen);
+        Vertice b = (Vertice) vertice(destino);
+        for (Vertice vertice : vertices)
+        {
+            vertice.distancia = Double.MAX_VALUE;
+        }
+        a.distancia = 0;
+        while (!monticulomin.esVacia())
+        {
+            Vertice ve = monticulomin.elimina();
+            for (Vecino vecino : ve.vecinos)
+            {
+                if (vecino.vecino.distancia > (ve.distancia + vecino.peso))
+                    vecino.vecino.distancia = ve.distancia + vecino.peso;
+                    monticulomin.reordena(vecino.vecino);
+            }
+        }
+        if (b.distancia == Double.MAX_VALUE)
+            return l;
+        l.agrega(b);
+        while (!b.elemento.equals(origen))
+        {
+            for (Vecino vecino : b.vecinos)
+            {
+                if (b.distancia == vecino.vecino.distancia + vecino.peso)
+                {
+                    l.agrega(vecino.vecino);
+                    b = vecino.vecino;
+                }
+            }
+        }
+        return l.reversa();
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/Lista.java b/src/main/java/mx/unam/ciencias/edd/Lista.java
index f56592a..73cd619 100644
--- a/src/main/java/mx/unam/ciencias/edd/Lista.java
+++ b/src/main/java/mx/unam/ciencias/edd/Lista.java
@@ -28,7 +28,7 @@ public class Lista<T> implements Coleccion<T> {
 
         /* Construye un nodo con un elemento. */
         public Nodo(T elemento) {
-            // Aquí va su código.
+            this.elemento = elemento;
         }
     }
 
@@ -41,37 +41,47 @@ public class Lista<T> implements Coleccion<T> {
 
         /* Construye un nuevo iterador. */
         public Iterador() {
-            // Aquí va su código.
+            this.start();
         }
 
         /* Nos dice si hay un elemento siguiente. */
         @Override public boolean hasNext() {
-            // Aquí va su código.
+            return this.siguiente != null;
         }
 
         /* Nos da el elemento siguiente. */
         @Override public T next() {
-            // Aquí va su código.
+            if (!this.hasNext())
+            throw new NoSuchElementException();
+            this.anterior = this.siguiente;
+            this.siguiente = this.siguiente.siguiente;
+            return this.anterior.elemento;
         }
 
         /* Nos dice si hay un elemento anterior. */
         @Override public boolean hasPrevious() {
-            // Aquí va su código.
+            return this.anterior != null;
         }
 
         /* Nos da el elemento anterior. */
         @Override public T previous() {
-            // Aquí va su código.
+            if (!this.hasPrevious())
+            throw new NoSuchElementException();
+            this.siguiente = this.anterior;
+            this.anterior = this.anterior.anterior;
+            return this.siguiente.elemento;
         }
 
         /* Mueve el iterador al inicio de la lista. */
         @Override public void start() {
-            // Aquí va su código.
+            this.anterior = null;
+            this.siguiente = cabeza;
         }
 
         /* Mueve el iterador al final de la lista. */
         @Override public void end() {
-            // Aquí va su código.
+            this.siguiente = null;
+            this.anterior = rabo;
         }
     }
 
@@ -88,7 +98,7 @@ public class Lista<T> implements Coleccion<T> {
      * @return la longitud de la lista, el número de elementos que contiene.
      */
     public int getLongitud() {
-        // Aquí va su código.
+        return this.longitud;
     }
 
     /**
@@ -97,7 +107,7 @@ public class Lista<T> implements Coleccion<T> {
      * @return el número elementos en la lista.
      */
     @Override public int getElementos() {
-        // Aquí va su código.
+        return this.longitud;
     }
 
     /**
@@ -106,7 +116,7 @@ public class Lista<T> implements Coleccion<T> {
      *         otro caso.
      */
     @Override public boolean esVacia() {
-        // Aquí va su código.
+        return this.cabeza == null;
     }
 
     /**
@@ -118,7 +128,20 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>null</code>.
      */
     @Override public void agrega(T elemento) {
-        // Aquí va su código.
+        if (elemento == null)
+        throw new IllegalArgumentException();
+        Nodo nuevo = new Nodo(elemento);
+        if (this.esVacia())
+        {
+            this.cabeza = this.rabo = nuevo;    
+        }
+        else
+        {
+            this.rabo.siguiente = nuevo;
+            nuevo.anterior = this.rabo;
+            this.rabo = nuevo;
+        }
+        this.longitud ++;
     }
 
     /**
@@ -129,7 +152,7 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>null</code>.
      */
     public void agregaFinal(T elemento) {
-        // Aquí va su código.
+        this.agrega(elemento);
     }
 
     /**
@@ -139,8 +162,22 @@ public class Lista<T> implements Coleccion<T> {
      * @throws IllegalArgumentException si <code>elemento</code> es
      *         <code>null</code>.
      */
-    public void agregaInicio(T elemento) {
-        // Aquí va su código.
+    public void agregaInicio(T elemento)
+    {
+        if (elemento == null)
+        throw new IllegalArgumentException();
+        Nodo nuevo = new Nodo(elemento);
+        if (this.esVacia())
+        {
+            this.cabeza = this.rabo = nuevo;    
+        }
+        else
+        {
+            this.cabeza.anterior = nuevo;
+            nuevo.siguiente = this.cabeza;
+            this.cabeza = nuevo;
+        }
+        this.longitud ++;
     }
 
     /**
@@ -159,7 +196,35 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>null</code>.
      */
     public void inserta(int i, T elemento) {
-        // Aquí va su código.
+        if (elemento == null)
+        throw new IllegalArgumentException();
+        if (this.longitud == 0)
+        {
+            agregaFinal(elemento);
+            return;
+        }
+        else if (i >= this.longitud)
+        {
+            agregaFinal(elemento);
+            return;
+        }
+        else if ( i <= 0)
+        {       
+            agregaInicio(elemento);
+            return;
+        }
+        this.longitud ++;
+        Nodo aux = this.cabeza;
+        int j=0;
+        while (aux != null && j < i) {
+            aux = aux.siguiente;
+            j++;
+        }
+        Nodo nuevo = new Nodo(elemento);
+        nuevo.siguiente = aux;
+        nuevo.anterior = aux.anterior;
+        aux.anterior.siguiente = nuevo;
+        aux.anterior = nuevo;
     }
 
     /**
@@ -167,8 +232,43 @@ public class Lista<T> implements Coleccion<T> {
      * lista, el método no la modifica.
      * @param elemento el elemento a eliminar.
      */
-    @Override public void elimina(T elemento) {
-        // Aquí va su código.
+    @Override public void elimina(T elemento)
+    {
+        Nodo elimina = BuscaElemento(elemento);
+        if (elimina == null)
+            return;
+        if (this.cabeza == this.rabo)
+        {
+            this.cabeza = this.rabo = null;
+        }
+        else if (this.cabeza == elimina)
+        {
+            this.cabeza = this.cabeza.siguiente;
+            this.cabeza.anterior = null;
+        }
+        else if (this.rabo == elimina)
+        {
+            this.rabo = this.rabo.anterior;
+            this.rabo.siguiente = null;
+        }
+        else
+        {
+            elimina.anterior.siguiente = elimina.siguiente; 
+            elimina.siguiente.anterior = elimina.anterior;
+        }
+        this.longitud -=1;
+    }
+
+    private Nodo BuscaElemento(T elemento)
+    {
+        Nodo n = this.cabeza;
+        while (n != null)
+        {
+            if (n.elemento.equals(elemento))
+                return n;
+            n = n.siguiente;
+        }
+        return null;
     }
 
     /**
@@ -176,8 +276,22 @@ public class Lista<T> implements Coleccion<T> {
      * @return el primer elemento de la lista antes de eliminarlo.
      * @throws NoSuchElementException si la lista es vacía.
      */
-    public T eliminaPrimero() {
-        // Aquí va su código.
+    public T eliminaPrimero()
+    {
+        if (this.esVacia())
+        throw new NoSuchElementException();
+        T eliminap = this.cabeza.elemento;
+        this.cabeza = this.cabeza.siguiente;
+        if (this.longitud == 1)
+        {
+            this.rabo = null;
+        }
+        else
+        {
+            this.cabeza.anterior = null;
+        }
+        this.longitud --;
+        return eliminap;
     }
 
     /**
@@ -185,8 +299,22 @@ public class Lista<T> implements Coleccion<T> {
      * @return el último elemento de la lista antes de eliminarlo.
      * @throws NoSuchElementException si la lista es vacía.
      */
-    public T eliminaUltimo() {
-        // Aquí va su código.
+    public T eliminaUltimo()
+    {
+        if (esVacia())
+        throw new NoSuchElementException();
+        T eliminau = this.rabo.elemento;
+        this.rabo = this.rabo.anterior;
+        if (this.longitud == 1)
+        {
+            this.cabeza = null;
+        }
+        else
+        {
+            this.rabo.siguiente = null;
+        }
+        this.longitud --;
+        return eliminau;
     }
 
     /**
@@ -196,7 +324,7 @@ public class Lista<T> implements Coleccion<T> {
      *         <code>false</code> en otro caso.
      */
     @Override public boolean contiene(T elemento) {
-        // Aquí va su código.
+        return this.BuscaElemento(elemento) != null;
     }
 
     /**
@@ -204,7 +332,14 @@ public class Lista<T> implements Coleccion<T> {
      * @return una nueva lista que es la reversa la que manda llamar el método.
      */
     public Lista<T> reversa() {
-        // Aquí va su código.
+        Lista<T> lista = new Lista<T>();
+        Nodo n = this.cabeza;
+        while (n != null)
+        {
+            lista.agregaInicio(n.elemento);
+            n = n.siguiente;
+        }
+        return lista;
     }
 
     /**
@@ -213,14 +348,27 @@ public class Lista<T> implements Coleccion<T> {
      * @return una copiad de la lista.
      */
     public Lista<T> copia() {
-        // Aquí va su código.
+        return copia(new Lista<T>(),cabeza);
+    }
+
+    private Lista<T> copia(Lista<T> copia, Nodo nodo)
+    {
+        if (nodo == null)
+        {
+            return copia;
+        }
+        copia.agregaFinal(nodo.elemento);
+        return copia(copia, nodo.siguiente);
     }
 
     /**
      * Limpia la lista de elementos, dejándola vacía.
      */
     @Override public void limpia() {
-        // Aquí va su código.
+        while (this.longitud != 0)
+        {
+            this.eliminaUltimo();
+        }
     }
 
     /**
@@ -229,7 +377,9 @@ public class Lista<T> implements Coleccion<T> {
      * @throws NoSuchElementException si la lista es vacía.
      */
     public T getPrimero() {
-        // Aquí va su código.
+        if (this.esVacia())
+        throw new NoSuchElementException();
+        return this.cabeza.elemento;
     }
 
     /**
@@ -238,7 +388,9 @@ public class Lista<T> implements Coleccion<T> {
      * @throws NoSuchElementException si la lista es vacía.
      */
     public T getUltimo() {
-        // Aquí va su código.
+        if (this.esVacia())
+            throw new NoSuchElementException();
+        return this.rabo.elemento;
     }
 
     /**
@@ -249,7 +401,16 @@ public class Lista<T> implements Coleccion<T> {
      *         igual que el número de elementos en la lista.
      */
     public T get(int i) {
-        // Aquí va su código.
+        if (i < 0 || i >= this.getLongitud())
+        throw new ExcepcionIndiceInvalido();
+        Nodo iesimo = this.cabeza;
+        int cont = 0;
+        while (cont != i)
+        {
+            iesimo = iesimo.siguiente;
+            cont ++;
+        }
+        return iesimo.elemento;
     }
 
     /**
@@ -259,15 +420,37 @@ public class Lista<T> implements Coleccion<T> {
      *         no está contenido en la lista.
      */
     public int indiceDe(T elemento) {
-        // Aquí va su código.
+        Nodo indice = this.cabeza;
+        int cont = 0;
+        while (indice != null)
+        {
+            if (indice.elemento.equals(elemento))
+                return cont;
+                cont += 1;
+                indice = indice.siguiente;
+        }
+        return -1;
     }
 
     /**
      * Regresa una representación en cadena de la lista.
      * @return una representación en cadena de la lista.
      */
-    @Override public String toString() {
-        // Aquí va su código.
+    @Override public String toString()
+    {
+        Nodo repre = this.cabeza;
+        String listastr = "[";
+        while (repre != null)
+        {
+            listastr += repre.elemento;
+            repre = repre.siguiente;
+            if (repre != null)
+            {
+                listastr += ", ";
+            }
+        }
+        listastr += "]";
+        return listastr;
     }
 
     /**
@@ -280,7 +463,16 @@ public class Lista<T> implements Coleccion<T> {
         if (objeto == null || getClass() != objeto.getClass())
             return false;
         @SuppressWarnings("unchecked") Lista<T> lista = (Lista<T>)objeto;
-        // Aquí va su código.
+        Nodo aux1 = this.cabeza;
+        Nodo aux2 = lista.cabeza;
+        while (aux1 != null && aux2 != null)
+        {
+            if (!aux1.elemento.equals(aux2.elemento))
+                return false;
+            aux1 = aux1.siguiente;
+            aux2 = aux2.siguiente;
+        }
+        return (aux1 != null) == (aux2 != null);
     }
 
     /**
@@ -307,10 +499,67 @@ public class Lista<T> implements Coleccion<T> {
      *                   ordenamiento.
      * @return una copia de la lista, pero ordenada.
      */
-    public Lista<T> mergeSort(Comparator<T> comparador) {
-        // Aquí va su código.
+
+    public Lista<T> mergeSort(Comparator<T> comparador)
+    {
+        if (this.esVacia() || this.longitud == 1)
+        {
+            return this;
+        }
+        Lista <T> lista1 = new Lista<T>();
+        Lista <T> lista2 = new Lista<T>();
+        Nodo nuevo = this.cabeza;
+        for (int i=0; i<this.longitud; i++)
+        {
+            if (i < longitud/2)
+            {
+                lista1.agrega(nuevo.elemento);
+            }
+            else
+            {
+                lista2.agrega(nuevo.elemento);
+            }
+            nuevo = nuevo.siguiente;
+        }
+        lista1 = lista1.mergeSort(comparador);
+        lista2 = lista2.mergeSort(comparador);
+        return mezcla(lista1,lista2,comparador);
     }
 
+    //con mezcla se crean 2 listas, con 2 nodos apuntando a las 2 cabezas de las listas y comparar;
+    private Lista<T> mezcla(Lista<T> lista1a, Lista<T> lista1b, Comparator<T> comparador)
+    {
+        Lista<T> listamezclada = new Lista<T>();
+        while (lista1b.cabeza != null && lista1a.cabeza != null)
+        {
+            int i = comparador.compare(lista1a.cabeza.elemento, lista1b.cabeza.elemento);
+            if (i <= 0)
+            {
+                listamezclada.agregaFinal(lista1a.getPrimero());
+                lista1a.eliminaPrimero();
+            }
+            else
+            {
+                listamezclada.agregaFinal(lista1b.getPrimero());
+                lista1b.eliminaPrimero();
+            }
+        }
+        while (lista1a.cabeza != null)
+        {
+            listamezclada.agregaFinal(lista1a.getPrimero());
+            lista1a.eliminaPrimero();
+        }
+        while (lista1b.cabeza != null)
+        {
+            listamezclada.agregaFinal(lista1b.getPrimero());
+            lista1b.eliminaPrimero();
+        }
+        return listamezclada;
+    }
+
+
+        
+
     /**
      * Regresa una copia de la lista recibida, pero ordenada. La lista recibida
      * tiene que contener nada más elementos que implementan la interfaz {@link
@@ -332,8 +581,16 @@ public class Lista<T> implements Coleccion<T> {
      * @return <code>true</code> si el elemento está contenido en la lista,
      *         <code>false</code> en otro caso.
      */
-    public boolean busquedaLineal(T elemento, Comparator<T> comparador) {
-        // Aquí va su código.
+
+    public boolean busquedaLineal(T elemento, Comparator<T> comparador)
+    {
+        return busquedaLineal(elemento, comparador, cabeza);
+    }
+
+    private boolean busquedaLineal(T elemento, Comparator<T> comparador, Nodo n)
+    {
+        return n == null ? false : (comparador.compare(elemento, n.elemento) == 0
+                         ? true : busquedaLineal(elemento, comparador, n.siguiente));
     }
 
     /**
diff --git a/src/main/java/mx/unam/ciencias/edd/MeteSaca.java b/src/main/java/mx/unam/ciencias/edd/MeteSaca.java
index 8864077..d9fde90 100644
--- a/src/main/java/mx/unam/ciencias/edd/MeteSaca.java
+++ b/src/main/java/mx/unam/ciencias/edd/MeteSaca.java
@@ -22,7 +22,7 @@ public abstract class MeteSaca<T> {
          * @param elemento el elemento del nodo.
          */
         public Nodo(T elemento) {
-            // Aquí va su código.
+            this.elemento = elemento;
         }
     }
 
@@ -42,8 +42,20 @@ public abstract class MeteSaca<T> {
      * @return el elemento en un extremo de la estructura.
      * @throws NoSuchElementException si la estructura está vacía.
      */
-    public T saca() {
-        // Aquí va su código.
+    public T saca()
+    {
+        if (this.esVacia())
+            throw new NoSuchElementException();
+        T elemento = this.cabeza.elemento;
+        if (this.cabeza == this.rabo)
+        {
+            this.cabeza = rabo = null;
+        }
+        else 
+        {
+            this.cabeza = cabeza.siguiente;
+        }
+        return elemento;
     }
 
     /**
@@ -52,8 +64,11 @@ public abstract class MeteSaca<T> {
      * @return el elemento en un extremo de la estructura.
      * @throws NoSuchElementException si la estructura está vacía.
      */
-    public T mira() {
-        // Aquí va su código.
+    public T mira()
+    {
+        if (this.esVacia())
+        throw new NoSuchElementException();
+        return this.cabeza.elemento;
     }
 
     /**
@@ -62,7 +77,7 @@ public abstract class MeteSaca<T> {
      *         <code>false</code> en otro caso.
      */
     public boolean esVacia() {
-        // Aquí va su código.
+        return  this.cabeza == null;
     }
 
     /**
@@ -76,6 +91,18 @@ public abstract class MeteSaca<T> {
         if (object == null || getClass() != object.getClass())
             return false;
         @SuppressWarnings("unchecked") MeteSaca<T> m = (MeteSaca<T>)object;
-        // Aquí va su código.
+        Nodo aux1 = this.cabeza;
+        Nodo aux2 = m.cabeza;
+        while (aux1 != null && aux2 != null)
+        {
+            if (!aux1.elemento.equals(aux2.elemento))
+                return false;
+            aux1 = aux1.siguiente;
+            aux2 = aux2.siguiente;
+        }
+        return aux1 == aux2;
+        // Nodos auxiliares
+        // Nodo aux1 = this.cabeza
+        // Nodo aux2 = m.cabeza
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/MonticuloArreglo.java b/src/main/java/mx/unam/ciencias/edd/MonticuloArreglo.java
index 125ce61..0f82072 100644
--- a/src/main/java/mx/unam/ciencias/edd/MonticuloArreglo.java
+++ b/src/main/java/mx/unam/ciencias/edd/MonticuloArreglo.java
@@ -37,7 +37,15 @@ public class MonticuloArreglo<T extends ComparableIndexable<T>>
      * @param n el número de elementos en el iterable.
      */
     public MonticuloArreglo(Iterable<T> iterable, int n) {
-        // Aquí va su código.
+        int indice = 0;
+        arreglo = nuevoArreglo(n);
+        for (T elemento : iterable)
+        {
+            arreglo[indice] = elemento;
+            elemento.setIndice(indice);
+            indice++;
+        }
+        elementos = n;
     }
 
     /**
@@ -45,8 +53,36 @@ public class MonticuloArreglo<T extends ComparableIndexable<T>>
      * @return el elemento mínimo del montículo.
      * @throws IllegalStateException si el montículo es vacío.
      */
-    @Override public T elimina() {
-        // Aquí va su código.
+    @Override public T elimina()
+    {
+        if(elementos == 0)
+        throw new IllegalStateException();
+        T elemento = null;
+        for (int i=0; i<arreglo.length; i++)
+        {
+            if (arreglo[i] != null)
+            {
+                elemento = arreglo[i];
+                break;
+            }
+        }
+
+        int elementoa = elemento.getIndice();
+        for(int i=1; i<arreglo.length; i++)
+        {
+            if (arreglo[i] != null)
+            {
+                if (elemento.compareTo(arreglo[i]) > 0)
+                {
+                  elemento = arreglo[i];
+                  elementoa = arreglo[i].getIndice();
+                }
+            }
+        }
+        arreglo[elementoa].setIndice(-1);
+        arreglo[elementoa] = null;
+        elementos--;
+        return elemento;
     }
 
     /**
@@ -57,7 +93,9 @@ public class MonticuloArreglo<T extends ComparableIndexable<T>>
      *         que el número de elementos.
      */
     @Override public T get(int i) {
-        // Aquí va su código.
+        if(i<0 || i>=elementos)
+        throw new NoSuchElementException();
+        return arreglo[i];
     }
 
     /**
@@ -66,7 +104,7 @@ public class MonticuloArreglo<T extends ComparableIndexable<T>>
      *         <code>false</code> en otro caso.
      */
     @Override public boolean esVacia() {
-        // Aquí va su código.
+        return (elementos == 0);
     }
 
     /**
@@ -74,6 +112,6 @@ public class MonticuloArreglo<T extends ComparableIndexable<T>>
      * @return el número de elementos en el montículo.
      */
     @Override public int getElementos() {
-        // Aquí va su código.
+        return this.elementos;
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/MonticuloMinimo.java b/src/main/java/mx/unam/ciencias/edd/MonticuloMinimo.java
index 1afb359..edf5798 100644
--- a/src/main/java/mx/unam/ciencias/edd/MonticuloMinimo.java
+++ b/src/main/java/mx/unam/ciencias/edd/MonticuloMinimo.java
@@ -17,12 +17,14 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
 
         /* Nos dice si hay un siguiente elemento. */
         @Override public boolean hasNext() {
-            // Aquí va su código.
+            return (indice < arbol.length) && (arbol[indice] != null);
         }
 
         /* Regresa el siguiente elemento. */
         @Override public T next() {
-            // Aquí va su código.
+            if (indice >= arbol.length)
+            throw new NoSuchElementException();
+            return arbol[indice++];
         }
     }
 
@@ -37,22 +39,23 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
 
         /* Crea un nuevo comparable indexable. */
         public Adaptador(T elemento) {
-            // Aquí va su código.
+            this.elemento = elemento;
+            this.indice = -1;
         }
 
         /* Regresa el índice. */
         @Override public int getIndice() {
-            // Aquí va su código.
+            return this.indice;
         }
 
         /* Define el índice. */
         @Override public void setIndice(int indice) {
-            // Aquí va su código.
+            this.indice = indice;
         }
 
         /* Compara un adaptador con otro. */
         @Override public int compareTo(Adaptador<T> adaptador) {
-            // Aquí va su código.
+            return this.elemento.compareTo(adaptador.elemento);
         }
     }
 
@@ -98,16 +101,95 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      *                 montículo.
      * @param n el número de elementos en el iterable.
      */
-    public MonticuloMinimo(Iterable<T> iterable, int n) {
-        // Aquí va su código.
+    public MonticuloMinimo(Iterable<T> iterable, int n) 
+    {
+        int a = 0,indice;
+        this.arbol = nuevoArreglo(n);
+        elementos = n;
+        for (T elemento : iterable)
+        {
+            arbol[a] = elemento;
+            elemento.setIndice(a);
+            a++;
+        }
+        indice = (n-1)/2;
+
+        for (int i=indice; i>=0; i--)
+            heapify_down(arbol[i]);
     }
 
     /**
      * Agrega un nuevo elemento en el montículo.
      * @param elemento el elemento a agregar en el montículo.
      */
-    @Override public void agrega(T elemento) {
-        // Aquí va su código.
+    @Override public void agrega(T elemento)
+    {
+        if (elementos == arbol.length)
+        {
+            T [] arbolx2 = nuevoArreglo(elementos*2);
+            for (int i=0; i<elementos; i++)
+                arbolx2[i] = arbol[i];
+
+            arbol = arbolx2;
+        }
+        arbol[elementos] = elemento;
+        elemento.setIndice(elementos);
+        elementos++;
+        heapify_up(elemento);
+    }
+
+    private void intercambia(T a, T b)
+    {
+        int aux = b.getIndice();
+        arbol[a.getIndice()] = b;
+        arbol[b.getIndice()] = a;
+        b.setIndice(a.getIndice());
+        a.setIndice(aux);
+    }
+
+    private boolean indiceValido(int i)
+    {
+        if (i < 0 || i >= elementos)
+            return false;
+        else
+            return true;
+    }
+
+    private void heapify_down(T elemento)
+    {
+        if (elemento == null)
+           return;
+        int izq = elemento.getIndice()*2 +1;
+        int der = elemento.getIndice()*2 +2;
+        if (!indiceValido(izq) && !indiceValido(der))
+           return;
+        int min = der;
+        if (indiceValido(izq))
+        {
+           if (indiceValido(der))
+            {
+              if (arbol[izq].compareTo(arbol[der]) < 0)
+              min = izq;
+            }
+            else
+            min = izq;
+        }
+        if (elemento.compareTo(arbol[min]) > 0)
+        {
+           intercambia(elemento,arbol[min]);
+           heapify_down(elemento);
+        }
+    }
+
+    private void heapify_up(T elemento)
+    {
+        int padre = elemento.getIndice()-1;
+        if (padre != -1)
+            padre/=2;
+        if (!indiceValido(padre) || arbol[padre].compareTo(elemento) < 0)
+            return;
+        intercambia(arbol[padre],elemento);
+        heapify_up(elemento);
     }
 
     /**
@@ -115,16 +197,34 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      * @return el elemento mínimo del montículo.
      * @throws IllegalStateException si el montículo es vacío.
      */
-    @Override public T elimina() {
-        // Aquí va su código.
+    @Override public T elimina()
+    {
+        if (esVacia())
+        throw new IllegalStateException();
+        T raiz = arbol[0];
+        T ultimo = arbol[elementos-1];
+        intercambia(raiz,ultimo);
+        elementos--;
+        arbol[elementos].setIndice(-1);
+        arbol[elementos] = null;
+        heapify_down(arbol[0]);
+        return raiz;
     }
 
     /**
      * Elimina un elemento del montículo.
      * @param elemento a eliminar del montículo.
      */
-    @Override public void elimina(T elemento) {
-        // Aquí va su código.
+    @Override public void elimina(T elemento)
+    {
+        int indice = elemento.getIndice();
+        if(!indiceValido(indice))
+            return;
+        intercambia(arbol[indice],arbol[elementos-1]);
+        elementos--;
+        arbol[elementos] = null;
+        elemento.setIndice(-1);
+        reordena(arbol[indice]);
     }
 
     /**
@@ -133,8 +233,13 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      * @return <code>true</code> si el elemento está contenido,
      *         <code>false</code> en otro caso.
      */
-    @Override public boolean contiene(T elemento) {
-        // Aquí va su código.
+    @Override public boolean contiene(T elemento)
+    {
+        int indice = elemento.getIndice();
+        if (!indiceValido(indice))
+            return false;
+        else
+            return true;
     }
 
     /**
@@ -143,22 +248,35 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      *         <code>false</code> en otro caso.
      */
     @Override public boolean esVacia() {
-        // Aquí va su código.
+        return elementos == 0;
     }
 
     /**
      * Limpia el montículo de elementos, dejándolo vacío.
      */
-    @Override public void limpia() {
-        // Aquí va su código.
+    @Override public void limpia()
+    {
+        for (int i=0; i<elementos; i++)
+            arbol[i] = null;
+        elementos = 0;
     }
 
    /**
      * Reordena un elemento en el árbol.
      * @param elemento el elemento que hay que reordenar.
      */
-    @Override public void reordena(T elemento) {
-        // Aquí va su código.
+    @Override public void reordena(T elemento)
+    {
+        if (elemento == null)
+            return;
+        int padre = elemento.getIndice()-1;
+        if (padre != -1)
+            padre/= 2;
+
+        if (!indiceValido(padre) || arbol[padre].compareTo(elemento) <= 0)
+            heapify_down(elemento);
+        else
+            heapify_up(elemento);
     }
 
     /**
@@ -166,7 +284,7 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      * @return el número de elementos en el montículo mínimo.
      */
     @Override public int getElementos() {
-        // Aquí va su código.
+        return this.elementos;
     }
 
     /**
@@ -177,7 +295,9 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      *         que el número de elementos.
      */
     @Override public T get(int i) {
-        // Aquí va su código.
+        if (i < 0 || i >= elementos)
+        throw new NoSuchElementException();
+        return arbol[i];
     }
 
     /**
@@ -185,7 +305,10 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      * @return una representación en cadena del montículo mínimo.
      */
     @Override public String toString() {
-        // Aquí va su código.
+        String s = "";
+        for (int i=0; i<arbol.length; i++)
+            s += arbol[i] + ", ";
+        return s;
     }
 
     /**
@@ -199,7 +322,13 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
             return false;
         @SuppressWarnings("unchecked") MonticuloMinimo<T> monticulo =
             (MonticuloMinimo<T>)objeto;
-        // Aquí va su código.
+        if (monticulo.getElementos() != getElementos())
+            return false;
+        for (int i=0; i<getElementos(); i++)
+            if (!arbol[i].equals(monticulo.get(i)))
+            return false;
+
+        return true;
     }
 
     /**
@@ -218,7 +347,15 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      * @return una lista ordenada con los elementos de la colección.
      */
     public static <T extends Comparable<T>>
-    Lista<T> heapSort(Coleccion<T> coleccion) {
-        // Aquí va su código.
+    Lista<T> heapSort(Coleccion<T> coleccion)
+    {
+        Lista<Adaptador<T>> l1 = new Lista<Adaptador<T>>();
+        for (T ec : coleccion)
+            l1.agrega(new Adaptador<T>(ec));
+        Lista<T> l2 = new Lista<T>();
+        MonticuloMinimo<Adaptador<T>> monticulo = new MonticuloMinimo<Adaptador<T>>(l1);
+        while (!monticulo.esVacia())
+            l2.agrega(monticulo.elimina().elemento);
+        return l2;
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/Pila.java b/src/main/java/mx/unam/ciencias/edd/Pila.java
index fc800e7..6056460 100644
--- a/src/main/java/mx/unam/ciencias/edd/Pila.java
+++ b/src/main/java/mx/unam/ciencias/edd/Pila.java
@@ -9,8 +9,18 @@ public class Pila<T> extends MeteSaca<T> {
      * Regresa una representación en cadena de la pila.
      * @return una representación en cadena de la pila.
      */
-    @Override public String toString() {
-        // Aquí va su código.
+    @Override public String toString()
+    {
+        String s = "";
+        if (this.esVacia())
+        	return s;
+        Nodo aux = this.cabeza;
+        while (aux != null)
+        {
+            s += aux.elemento + "\n";
+            aux = aux.siguiente;
+        }
+        return s;
     }
 
     /**
@@ -19,7 +29,19 @@ public class Pila<T> extends MeteSaca<T> {
      * @throws IllegalArgumentException si <code>elemento</code> es
      *         <code>null</code>.
      */
-    @Override public void mete(T elemento) {
-        // Aquí va su código.
+    @Override public void mete(T elemento)
+    {
+        if (elemento == null)
+        throw new IllegalArgumentException();
+        Nodo nuevo = new Nodo(elemento);
+        if (this.esVacia())
+        {
+            this.rabo = nuevo;
+        }
+        else
+        {
+            nuevo.siguiente = this.cabeza;
+        }
+        this.cabeza = nuevo;
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/ValorIndexable.java b/src/main/java/mx/unam/ciencias/edd/ValorIndexable.java
index 15ba2bf..bdb4d5a 100644
--- a/src/main/java/mx/unam/ciencias/edd/ValorIndexable.java
+++ b/src/main/java/mx/unam/ciencias/edd/ValorIndexable.java
@@ -18,8 +18,11 @@ public class ValorIndexable<T>
      * @param elemento el elemento.
      * @param valor su valor.
      */
-    public ValorIndexable(T elemento, double valor) {
-        // Aquí va su código.
+    public ValorIndexable(T elemento, double valor)
+    {
+        this.elemento = elemento;
+        this.valor = valor;
+        this.indice = -1;
     }
 
     /**
@@ -27,7 +30,7 @@ public class ValorIndexable<T>
      * @return el elemento del valor indexable.
      */
     public T getElemento() {
-        // Aquí va su código.
+        return this.elemento;
     }
 
     /**
@@ -37,8 +40,13 @@ public class ValorIndexable<T>
      *         es menor que el parámetro; cero si son iguales; o mayor que cero
      *         si es mayor.
      */
-    @Override public int compareTo(ValorIndexable<T> valorIndexable) {
-        // Aquí va su código.
+    @Override public int compareTo(ValorIndexable<T> valorIndexable)
+    {
+        if (this.valor == valorIndexable.getValor())
+            return 0;
+        if (this.valor > valorIndexable.getValor())
+            return 1;
+        return -1;
     }
 
     /**
@@ -46,7 +54,7 @@ public class ValorIndexable<T>
      * @param indice el nuevo índice.
      */
     @Override public void setIndice(int indice) {
-        // Aquí va su código.
+       this.indice = indice;
     }
 
     /**
@@ -54,7 +62,7 @@ public class ValorIndexable<T>
      * @return el índice del valor indexable.
      */
     @Override public int getIndice() {
-        // Aquí va su código.
+        return this.indice;
     }
 
     /**
@@ -62,7 +70,7 @@ public class ValorIndexable<T>
      * @param valor el nuevo valor.
      */
     public void setValor(double valor) {
-        // Aquí va su código.
+        this.valor = valor;
     }
 
     /**
@@ -70,7 +78,7 @@ public class ValorIndexable<T>
      * @return el valor del valor indexable.
      */
     public double getValor() {
-        // Aquí va su código.
+        return this.valor;
     }
 
     /**
@@ -84,7 +92,10 @@ public class ValorIndexable<T>
             return false;
         @SuppressWarnings("unchecked") ValorIndexable<T> valorIndexable =
             (ValorIndexable<T>)objeto;
-        // Aquí va su código.
+        if (valor == valorIndexable.getValor())
+            return true;
+        else
+            return false;
     }
 
     /**
@@ -92,6 +103,6 @@ public class ValorIndexable<T>
      * @return una representación en cadena del valor indexable.
      */
     @Override public String toString() {
-        // Aquí va su código.
+        return this.elemento + String.format(":%2.9f", valor);
     }
 }
